스프링 시큐리티

MySQL db 에 저장한다


구현 
	인증 > 로그인
	인가 > :  클라이언트의 요청이 특정 Controller 클래스에 도달하기 전, 필터에서 Spring Security가 검증을 하는 과정.  
		1. 해당 경로의 접근은 누구에게 열려 있는지
		2. 로그인이 완료된 사용자인지
		3. 해당되는 role을 가지고 있는지

	회원가입 > db 저장


-----------------------------------------------------------------------------------------------------------

와일드 카드 표현 == ** 


-----------------------------------------------------------------------------------------------------------


스프링 시큐리티에서는 회원이나 계정에 대해서 User라는 용어를 사용.User라는 단어를 사용할 때는 상당히 주의. (키워드)



Spring Security 에서 계속 username username 거리는데, username  ==  (실제로 사용자의 성함을 의미하는게 아니라 ) 계정의 고유한 값, 그러니까 id 역할을 한다고 봄 된다.
	: email 같은 값도 username 이 될 수 있겠지만, 걍 PK 값을 username 으로 해라.

-----------------------------------------------------------------------------------------------------------
: 일반적인 스프링 부트 프로젝트 흐름
	▼ 요청
		▼ 서블릿 컨테이너
			▼ 필터
				▼ 스프링부트 컨트롤러

: 스프링 시큐리티 흐름 > spring security config 파일을 등록
	▼ 요청
		▼ 서블릿 컨테이너
			▼필터 ▼spring security config : 자바 config 파일을 등록해두면 특정 필터를 만들어서 그 요청을 가로챈다. 클라이언트의 요청을 목적지로 전달하기 전에 해당 클라이언트가 특정 권한을 가지고 있는지 검증한다(==인가작업). 권한이 없으면 해당 컨트롤러로의 접근을 막고 권한이 있으면 요청 전달해준다
					▼ 스프링부트 컨트롤러 : 로그인과 같은 작업 진행
						▼ 세션: 로그인 중인 사용자와 같은 정보 저장


-----------------------------------------------------------------------------------------------------------

- 필수 의존성
    - Spring Web
    - Lombok
    - Mustache
    - Spring Security
    - Spring Data JPA
    - MySQL Driver


스프링 시큐리티 버전에 따른 릴리즈 목록은 아래의 스프링 부트 공식 리포지토리에서 확인 가능
	: https://github.com/spring-projects/spring-security/releases
	: 람다 형식으로"만" 내부 메서드를 구현해야된다

	public class SpringSecurityConfig {

	    @Bean
  	  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

    	    	http
         		.authorizeHttpRequests((auth) -> auth
           	       .requestMatchers("/login", "/join").permitAll()
           	       .anyRequest().authenticated()
     	   );

       	 return http.build();
   	 	}
	}


-----------------------------------------------------------------------------------------------------------

처음엔 로그인 화면이 자동으로 뜬다
	: Spring Security를 의존성으로 추가한 상태에서 security config 파일을 설정하지 않은 경우 기본적으로 모든 요청에 대해 로그인 페이지가 뜨게 되어있기 떄문
	: 로그인 하는 법
		id : user
		pw : 로그에 올라오는 pw


-----------------------------------------------------------------------------------------------------------

SecurityConfig 클래스 
	: 인가 설정 하는 클래스
	: 구현 방법
		1. config 패키지 생성
		2. SecurityConfig.java 명으로 클래스 생성
		3. 해당 클래스명 위에 
			@Configuration 작성 : Configuration 클래스로 등록
 			@EnableWebSecurity 작성 : 스프링 시큐리티의 관리 대상이 됨.

		4. 클래스 내부에 메서드 작성 :  SecurityConfig 클래스 내부에서 빈으로 등록시킨 얘들은 자동으로 필터가 된다.



         상단에서 정의한 것부터 우선적으로 적용되기 떄문에 순서에 유의한다
             anyRequest( ) 를 가장 먼저 쓰면 그 밑에 쓴 requestMatchers(.. ) 에 대한 모든 설정은 다 무시된다 


        authorizeHttpRequests( 람다식 )  >> 특정 경로로의 요청을 허용하거나 거부함
         requestMatchers( "경로1" , "경로2" , ... ) >> 특정 경로에 대해 설정할 수 있게 함
             permitAll() >> 모든 사용자에게 로그인을 하지 않아도 접근할 수 있게 하는 메서드
             hasRole(String role) >> 특정한 role, 규칙이 있어야 경로에 접근할 수 있게 함
             hasAnyRole(String role1 , String role2, ... ) >>특정한 role, 규칙 중 하나여야 경로에 접근할 수 있게 함
             authenticated() >> 로그인만 잘 하면 접근할 수 있게 함
             denyAll() >> 모든 사용자의 접근을 막음. 로그인을 진행해도 접근하지 못하게 함.

         anyRequest( )  이외의 ( requestMatchers 에 의해 ) 설정되지 않은 모든 경로들



-----------------------------------------------------------------------------------------------------------

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{
        http.authorizeHttpRequests(
                (auth) ->auth
                        .requestMatchers("/","/login").permitAll()
                        .requestMatchers("/admin").hasRole("ADMIN")requestMatchers("/admin").hasRole("ADMIN")
                        .requestMatchers("/my/**").hasAnyRole("ADMIN","USER")
                        .anyRequest().authenticated());

        return http.build();  // 최종적으로 받았던 httpSecurity 를 빌더 타입으로 리턴해준다
    }
}




위에서 requestMatchers("/admin").hasRole("ADMIN") 이 설정되었기 떄문에 /admin 으로 접속하려하면 "localhost에 대한 액세스가 거부됨" 이라는 메세지와 함꼐 접근이 거부된다. 

리다이렉팅. 로그인 페이지 작업을 모두 커스텀 해주어야한다.


-----------------------------------------------------------------------------------------------------------

커스텀 로그인 
	: 마찬가지로 SecurityConfig 클래스에서 설정을 진행한다
	: https://velog.io/@gmtmoney2357/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-Form-Login-%EC%9D%B8%EC%A6%9D

	.formLogin() : form 로그인 인증 기능이 작동함

       .loginPage( "경ㅀ" ) : 커스텀 로그인 페이지 경로를 설정(등록)한다. 설정을 하면 로그인을 해야하는 상황에서 해당 경로로 리다이렉션 하게 된다.


	.loginProcessingUrl("경로") : 로그인데이터의 action 경로를 설정한다. 이 경로로 입력 데이터가 보내진다.

 	.permitAll(); 인증 없이 접근 가능하게 한다

csrf >> 위변조방지 설정. 동작이 되면 호스트 요청을 보낼 떄 csrf 토큰도 보내주어야 로그인이 진행된다
	: 스프링 시큐리티엔 자동으로 설정되있다 
	: 이건 이후 강의에 더 자세히 다루고 지금은 잠시 꺼두자




@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{
     
        http.authorizeHttpRequests(
                (auth) ->auth
                        .requestMatchers("/","/login","/join","/joinProc").permitAll()
                        .requestMatchers("/admin").hasRole("ADMIN")
                        .requestMatchers("/my/**").hasAnyRole("ADMIN","USER")
                        .anyRequest().authenticated());


  

        http.formLogin((auth)->auth
                .loginPage("/login")
                .loginProcessingUrl("/loginProc")
                .permitAll() ); // 로그인 페이지와 로그인 정보를 전달할 action url은 .permitAll된다. 즉, 인증이 없이 접근이 가능하다. 로그인을 하기 위한 로그인은 필요없다.

        http.csrf(auth->auth.disable());
        
        return http.build();     }
}



로그인페이지 요청 경로를 "/login" 로 하고 , 입력받은로그인데이터는 "/loginProc" 로 전달하고.  로그인페이지와 로그인 정보가 전달된 페이지에 대한 접근은 모두에게 허용한다.



-----------------------------------------------------------------------------------------------------------

BCrypt 암호화 메소드

스프링 시큐리티는 암호화를 무조건적으로 진행해야된다.
	: 스프링 시큐리티는 사용자 인증(로그인)시 아이디와 비밀번호에 검증을 한다. 이때 비밀번호를 단방향 해시 암호화하여 저장되어 있는 비밀번호와 대조한다.
		: 대조를 할 떄 해시화된걸로 비교하기 때문에 저장 할 떄 해쉬화해서 저장해야된다
			: 그러니까 회원가입시 비밀번호 항목에 대해서 암호화를 진행해야 한다.
			: 스프링 시큐리티는 암호화를 위해 BCrypt Password Encoder 라는 암호화 도구. 클래스를 제공하고 권장한다. 따라서 해당 클래스를 return하는 메소드를 만들어 @Bean으로 (회원 가입할 떄, 검증할 때 자동으로 사용하도록) 등록하여 사용하면 된다. 



암호화의 종류
	: 양방향
 	  	 - 대칭키
   		 - 비대칭키

	: 단방향 >> 다시 해독이 불가한 암호화
   		 - 해시




@Configuration
@EnableWebSecurity
public class SecurityConfig {


    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder(){
        return new BCryptPasswordEncoder(); 
    }


    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{
     
        http.authorizeHttpRequests(
                (auth) ->auth
                        .requestMatchers("/","/login","/join","/joinProc").permitAll()
                        .requestMatchers("/admin").hasRole("ADMIN")
                        .requestMatchers("/my/**").hasAnyRole("ADMIN","USER")
                        .anyRequest().authenticated());


  

        http.formLogin((auth)->auth
                .loginPage("/login")
                .loginProcessingUrl("/loginProc")
                .permitAll() ); // 로그인 페이지와 로그인 정보를 전달할 action url은 .permitAll된다. 즉, 인증이 없이 접근이 가능하다. 로그인을 하기 위한 로그인은 필요없다.

        http.csrf(auth->auth.disable());
        
        return http.build();     }
}




호출되면 BCryptPasswordEncoder 가 자동으로 생성될 수 있게 하는 메서드를 SecurityConfig에 @Bean 으로 추가해 어떤 곳에서든 다 호출에서 쓸 수 있게 한다.






@Service
public class JoinService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private BCryptPasswordEncoder bCryptPasswordEncoder; // 암호화(해시화)를 해서 데이터를 저장해야됨





    public void joinProccess(JoinDTO dto){ //joinController 단에서 받은 데이터를 db에 저장한다


        UserEntity data = new UserEntity();

        data.setUsername(dto.getUsername());
        data.setPassword(bCryptPasswordEncoder.encode(dto.getPassword())); // encode( ) 로 암호화 진행
        data.setRole("ROLE_USER"); 
        userRepository.save(data);

    }
}



앞서 등록한 BCryptPasswordEncoder 를 서비스 단에서 DI 받아서, 비밀번호를 저장하기 전에 encode( )메서드를 통해 암호화하고 저장한다.



-----------------------------------------------------------------------------------------------------------

build.gradle : 의존성 관리하는 파일
	: 이전에 잠시 주석 처리 해놨던 jpa 와 mysql 관련된 dependency 주석 해제한다


직접 쿼리문 안쓰고 JPA 라는 ORM 을 사용할꺼다


스프링 부트와 db (mySql )단일연결하기
	: application.properties / .yml 을 통해 쉽게 설정 가능하다


application.properties 설정하기
	: MySQL 연결 설정
	1. spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
		: 의존성추가한드라이버( mysql드라이버 ) 의 주소를넣는다
	2. spring.datasource.url=jdbc:mysql://아이피:3306/데이터베이스?useSSL=false&useUnicode=true&serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true
		: 아이피 >> localhost
		: 데이터베이스 >> schema . db명
		: 그 뒤에 자잘하게 붙는 쿼리 스트링은 SSL , timezone, key 같은거 설정
	3. spring.datasource.username=아이디
	4. spring.datasource.password=비밀번호


	: ddl 관련 설정
		: ddl 설정을 통해 스프링 부트 프로젝트에 존재하는 Entity를 기반으로 MySQL DB에 테이블 자동 생성이 가능하다.
		: 필수는 아니다


	1. spring.jpa.hibernate.ddl-auto=값
		할당가능한값
			none : 아무것도 건들이지 말란 뜻.
			create : 내 엔티티 기반으로 자동으로 테이블 생성하게 한다. 기존 테이블이 존재한다면 기존 테이블을 delete 하기 떄문에 좀 위험하다.
			update :내 엔티티 기반으로 자동으로 테이블 생성하게 한다. 기존 테이블이 존재한다면 따로 새로 만들진 않고, 내 엔티티가 추가적으로 가지는 column 이 있다면 해당 테이블에 그 column 들을 추가한다
			


-----------------------------------------------------------------------------------------------------------

회원가입로직
	: db에 저장된 회원정보를 통해 인증 인가 작업을 진행하기 때문에 본격 실습전 db에 회원 정보를 저장하고 시작한다

	: 전체적으로 MVC 패턴 그낭 알던 대로 짜고, Entity 도 짜는데 id, name , pw 뿐 아니라 "role" 에대한 필드도 따로 만든다.

	: 테이블을 "처음"에 직접 생성 할 필요 없이 아래와 같은 문장을 applicatoin.properties 에 추가하여 자동 생성하게 한다
	******: 처음에 테이블 쿼리문으로 생성하기 귀찮아서 이러는거지, 다음에도 이 상태로 돌리면 기존 데이터 덮어 쓰게 됨으로 생성 된 후에는 꼭 ddl-auto=none 으로 바꿔서 진행한다.
		spring.jpa.hibernate.ddl-auto=update혹은create
		spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl




-----------------------------------------------------------------------------------------------------------

role. 권한
	: https://cordcat.tistory.com/97

	:  사용자의 권한 설정
		: roles(String role1, role2, ..  ) 메서드를 이용하여 사용자에게 권한을 부여할 수 있다.
		: 권한은 여러개 부여할 수 있고,  "ROLE_XXXX"  과 같이 ROLE_접두사로 시작한다
			: XXXX 에는 role 의 이름을 넣음 되는데 작명은 맘대로 해둠 되는 것 같다

@Setter
@Getter
@Entity
public class UserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;


    @Column(unique = true)
    private String username;
    private String password;

    private String role; // ****권한을 저장한다
    
    


}



일단 권한을 부여하면 저장할 수 있게 엔티티의 필드를 생성한다

@Service
public class JoinService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private BCryptPasswordEncoder bCryptPasswordEncoder;

    public void joinProccess(JoinDTO dto){ 


        UserEntity data = new UserEntity();

        data.setUsername(dto.getUsername());
        data.setPassword(bCryptPasswordEncoder.encode(dto.getPassword())); 
        data.setRole("ROLE_USER"); // 권한 부여
        userRepository.save(data);

    }
}



서비스 단에서 저장하기 전에 권한을 부여하고 저장한다



	:: 자원에 대한 권한 설정
		: HttpSecurity'객체를 대상으로 
			http. authorizeHttpRequests( auth -> auth.
			.antMatchers("/admin/**").hasRole("ADMIN")
   			 .antMatchers("/user/**").hasRole("USER")
			)
			
			와 같이 특정권한을 가진 사용자만 접근을 허용하면 그게 자원에 대한 권한 설정인거다.


		: hasRole 을 통하여 권한 검사할 때는 권한을 부여할 떄와는 다르게 "XXXX" 그 자체로 쓴다.



-----------------------------------------------------------------------------------------------------------

username 값이 중복되지 않도록 해줘야된다

step 1. 일단 entity 단에서 애초에 중복이 안되게 방지한다

특정column 값 중복 금지 > 해당 엔티티의 필드 위에 @Column( unique = true ) 를 해준다

@Setter
@Getter
@Entity
public class UserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true)
    private String username; // 중복 금지

    private String password;

    private String role; 


}


step 2. entity 생성하기 전에 해당 username 이 존재하는지 확인하는 메서드 만든다 > repository 에 existByUsername( ) 커스텀 선언한다.


public interface UserRepository extends JpaRepository<UserEntity, Long> {

    public abstract  boolean existsByUserName(String userName);
}



step 3. 위에서 선언한 메서드를 서비스 단에서 활용한다


@Service
public class JoinService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private BCryptPasswordEncoder bCryptPasswordEncoder; 


    public void joinProccess(JoinDTO dto){ 

        //db 에 이미 해당 username 을 가진 회원이 존재하면 걍 엔티티 자첼 안만듬
        boolean isUser = userRepository.existsByUserName(dto.getUsername());
        if(isUser) return;
        
        UserEntity data = new UserEntity();
        data.setUsername(dto.getUsername());
        data.setPassword(bCryptPasswordEncoder.encode(dto.getPassword()));
        data.setRole("ROLE_USER"); 
        userRepository.save(data);

    }
}


-----------------------------------------------------------------------------------------------------------


로그인 검증 로직
	: https://velog.io/@jyyoun1022/SpringSpring-Security%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%B2%98%EB%A6%AC-5
	: https://velog.io/@daryu519/Spring-Security-User-UserDetailsService

username과 password를 "동시"에 사용하지 "않는다". 
스프링 시큐리티는 
1. UserDetailsService를 이용해서 회원의 존재( UserDetails ) 만을 우선적으로 가져옴
2. 이후에 password가 틀리면 'Bad Cridential'이라는 결과를 만들어 냄
3. (password가 맞아서) 사용자의 username과 password로 인증 과정이 끝나면 원하는 자원(URL)에 접근할 수 있는 적절한 권한이 있는지를 확인
4. 권한 있으면 접근 허용




	: 왜 DTO 를 이미 만들었는데도 UserDetails (와 이를 반환하는 UserDetailsService )가 필요한 것일 까 >> "DTO 정보 + 인증 관련 정보"를 포함하고 있는 인증 관련 정보를 담은 객체를 만들기 위해 UserDetails가 필요하고, UserDetails를 반환 받기 위해 UserDetailsService가 필요한 것.


	: CustomerUserDetailsService 
		: 스프링이 제공하는 UserDetailsService 를 impelements해서 만든 서비스 단이다
			: 유저의 인증에 필요한 사용자 정보들(username, password, authorities)를 제공한다.
			:: interface  UserDetailsService  > Spring Security에서 유저의 정보를 가져오는 인터페이스
				: UserDetails loadUserByUsername(String username ) > 유저의 정보를 불러와서 UserDetails로 리턴해준다

@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        UserEntity userData = userRepository.findByUserName(username); // repository 의 메서드를 활용해 db 상에 해당 username 을 가진 사용자가 등록되있나 검사
        
        if(userData !=null) return new CustomUserDetails(userData); //  등록되어있으면 로그인 허용
        return null;  // 아니면 허용 안함
    }
}


사용자가 "로그인"을 하면 SpringSecurityConfig 에서 검증을 위해 username 을 자동으로
UserDetailsService을 구현한  CustomUserDetailsService 에게 넘겨주고 이에 대해 
loadUserByUsername 이 해당 username 을 가진 사용자가 db 에 등록되어있는지 검증하게 되고 이를 수행하는 코드를 작성한다.

CustomUserDetails 는 아래에서 따로 """dto 패키지"""에 만든다.




	: CustomUserDetails
		: 스프링이 제공하는 UserDetails 를 implements 한 클래스
			: userDetails >> Spring Security에서 사용자의 정보를 담는 인터페이스로,  사용자의 정보를 불러오기 위해서 구현해야 된다.
			: 가장 중요한 메서드는 

	*******: "dto" 패키지에 만든다 !!!
			: 사용자의 정보를 담는. 제공하는 역할을 하니까.

		: CustomUserDetailsService 가 



public class CustomUserDetails implements UserDetails {

    private UserEntity userEntity;

    public CustomUserDetails(UserEntity userData) {
        this.userEntity = userData;
    }


    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() { // 사용자의 권한 정보를 제공
        //GrantedAuthority 라는 인터페이스를 요소로 하는 컬랙션 객체 생성
        Collection<GrantedAuthority> collection = new ArrayList<>();

        // role 을 넣어줌
        // 익명 구현 객체 생성 >> getAuthority( ) 가 엔티티의 role 필드를 반환하게 함.
        collection.add( new GrantedAuthority(){
            @Override
            public String getAuthority() {
                return userEntity.getRole();
            }
        });

        return collection;
    }

    @Override
    public String getUsername() { //인증에 필요한 아이디 같은 정보
        return userEntity.getUsername();
    }

    @Override
    public String getPassword() { // 인증을 마무리하기 위한 패스워드 정보 제공
        return userEntity.getPassword();
    }


    // 체크하는 메서드
        // 원래 db에 이러한 정보 다 있었어야됬는데 현재 저장한게 없으므로 일단 다 true 처리

    @Override
    public boolean isAccountNonExpired() { // 만료되었는지
        return true;
    }

    @Override
    public boolean isAccountNonLocked() { // 계정이 잠기지 않았는지
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}


-----------------------------------------------------------------------------------------------------------

 세션 정보 활용
	: 로그인인 된 상태에서 로그인 되었음을 표시같은 걸 표시 가능

@Controller
public class MainController {

    @GetMapping("/") 
    public String mainP(Model model){

//코드 복붙. 이건 원래 서비스 단에서 해야되는 거긴함.
        
        // id 를 얻어온다
        String id = SecurityContextHolder.getContext().getAuthentication().getName();


        // 권한을 얻어온다
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
        Iterator<? extends GrantedAuthority> iter = authorities.iterator();
        GrantedAuthority auth = iter.next();
        String role = auth.getAuthority();

        model.addAttribute("id",id);
        model.addAttribute("role",role);
        return "main";
    }
}

   
사실 이건 서비스 단에서 처리해야됨
	: id 를 얻어오는 법 >>     String id = SecurityContextHolder.getContext().getAuthentication().getName();

	: 권한을 얻어오는 법 >> 
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
        Iterator<? extends GrantedAuthority> iter = authorities.iterator();
        GrantedAuthority auth = iter.next();
        String role = auth.getAuthority();


-----------------------------------------------------------------------------------------------------------

세션 설정


로그인 정보
	: 사용자가 로그인을 진행한 뒤 사용자 정보는 SecurityContextHolder 라는 내부 세션에 저장된다. 세션에 대한 세션 id 는 사용자에게 cookie 로 반환된다.

세션 타임아웃 설정>> 세션의 소멸시간 설정.
	: 로그인 한 후에 자동으로 로그아웃 시켜서 언제 다시 로그인하게 할 건지
	: 로그인 진행 한 후 특정 요청 처리 후 count down 이 시작
		: 기본은 1800 초. (30 분)
	: 시간 너무 빡빡하게 주면 글쓰기 하는 중에 타임 아웃 됬다고 로그아웃 시켜서 글 쓴거 날라가는 불참사가 일어날 수 있음





