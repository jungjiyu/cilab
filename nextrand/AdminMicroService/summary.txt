미들웨어 :  데이터를 주고 받을 수 있도록 중간에서 매개 역할을 하는 소프트웨어

js 에서의 모듈 module : 파일 하나를 여러개로 분리해 생성된 각각의 파일 . 그 파일은 대체로 클래스 하나 혹은 복수의 함수로 구성된 라이브러리 하나로 이뤄짐.
	: export >> 해당 파일을 다른 파일에서 import 하여 사용할 수 있게 함
	: import >>  export 된 다른 파일의 함수 등을 호출하여 해당 파일에서 사용
	: 나중에 자세히 보기>> https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%AA%A8%EB%93%88-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-import-export-%EC%A0%95%EB%A6%AC



abstract 클래스를 쓰는 경우 : 직접적인 인스턴스화를 방지하고자 할때
	: (ENUM 처럼 걍 이름만 띡 있는게 아니라) 값을 가지는 상수를 저장하는 용도로만 쓸 때.
클래스가 직접적인 인스턴스화를 의도하지 않을 때.
	: AdminMicroService 프젝의 ApiRoutes 클래스가 이에 해당 

ENUM
	: https://studyandwrite.tistory.com/106
	: 한 클래스에 종속적이게 만들 수도 있고 별도로 만들 수도 있다

	: 종류
		(1) 기본적인 enum 선언 >> 상수들을 대문자로 선언
			: 각 상수는 앞에서부터 0, 1, 2, .. 의 값을 가지게 됨
		public enum 대문자시작이름{
			상수명1, 상수명2, 상수명3 .. 
			}

		: 세미콜론 안쓰는거 주의

		(2)멤버 변수를 추가 + 상수와 연관된 데이터를 상수 자체에 포함시켜 enum 선언 >> 
		: enum 상수 이름 옆에 원하는 값을 괄호와 함께 적어주고, 괄호 내부 적은 값의 타입에 대응하는 필드를 만들어준다
		: 메서드도 필요함 만들 수 있다.

		: 선언 예시 >> 

@Getter
@AllArgsConstructor
public enum ExceptionMessages {
    INVALID_TOKEN("토큰이 올바르지 않습니다."),
    NO_USER_FOUND("유저 정보를 조회할 수 없습니다."),
    NO_ADMIN_FOUND("어드민 정보를 조회할 수 없습니다."),
    SERVER_COMMUNICATION_FAILED("서버간의 통신에 문제가 있습니다."),
    NAS_SERVER_FAILED("NAS 서버와의 통신 중 오류가 있습니다."),
    CANNOT_FIND_DOCUMENT("문서를 조회할 수 없습니다"),
    CANNOT_FIND_ENTITY("엔티티를 조회할 수 없습니다"),
    INVALID_REQUEST("잘못된 요청값 입니다.");
    private String message;
}


		: 사용예시>> ExceptionMessages.SERVER_COMMUNICATION_FAILED.getMessage( );
			: "서버간의 통신에 문제가 있습니다." 의 값을 반환한다.
		


스프링 부트2 에서 javax 패키지명 >> 스프링 부트3에서는 jakarta 로 변경

엔드포인트 : 백엔드 앞단 URL

swagger
	: API 명세 도와주는 도구. API를 어떤 식으로 사용해야하는지 상대(프론트엔드팀, 백엔드팀)에게 쉽게 알려주는것. OAS (Open Api Specification)을 위한 프레임워크


-------------------------------------------------------------------------------------------------------------

AdminMicroService


swagger
	: swagger-ui.path를 딱히 지정하지 않았기 때문에 기본 path 인  swagger-ui/index.html 를 경로로 하여 http://localhost:8080/swagger-ui/index.html 로 접근 가능
	
restTemplate : spring에서 제공하는  "http 메서드기반으로 rest api 통신을 쉽게 할 수 있게 설계되어있는 템플릿" 
	: https://blog.naver.com/hj_kim97/222295259904
	: REST API 호출이후 응답을 받을 때까지 기다리는 동기방식으로 작동
		: 비동기/동기방식 모두 가능하게 한건 WebClient  >> Spring 5에 추가된 논블럭, 리엑티브 웹 클리이언트로 동기, 비동기 방식을 지원

	: 동작 원리: RestTemplate은 통신 과정을 ClientHttpRequestFactory(ClientHttpRequest, ClientHttpResponse)에 위임하고,  ClientHttpRequestFactory가 해당 API 로 request 하고 response 해서 RestTemplate에게 반환해주면 최종적으로 해당 response 결과를 json 의 형태로 반환한다.

		1. 애플리케이션 내부에서 REST API에 요청하기 위해 RestTemplate의 메서드를 호출한다.
		2. RestTemplate은 MessageConverter를 이용해 java object를 request body에 담을 message(JSON etc.)로 변환한다. 메시지 형태는 상황에 따라 다름
		3. ClientHttpRequestFactory에서 ClientHttpRequest을 받아와 요청을 전달한다.
		4. 실질적으로 ClientHttpRequest가 HTTP 통신으로 요청을 수행한다.
		5. RestTemplate이 에러핸들링을 한다.
		6. ClientHttpResponse에서 응답 데이터를 가져와 오류가 있으면 처리한다.
		7. MessageConverter를 이용해 response body의 message를 java object로 변환한다.
		8. 결과를 애플리케이션에 돌려준다.
		


	: 대표 메서드	
		(0) any : 
		****** 1. ResponseEntity exchange :  http 헤더를 생성하여 추가할 수 있고 , 모든 형식의 요청에서 다 사용 가능

		(1) HTTP GET 방식 : get 방식 요청 결과를 object|| ResponseEntity 로 반환
			1. Object getForObject 
			2. ResponsEntity getForEntity   


		(2) HTTP POST 방식 : post 방식 요청 결과를 object|| ResponseEntity 로 반환
			1. Object postForObject 
			2. ResponseEntity postForEntity

		(3) HTTP DELETE 방식
			1. void delete

		(4) HTTP PUT 방식
			1. void put
	
		(5) HTTP PATCH 방식
			1. void patchForObject 


	: 사용방법

spring security
	: 일반적인 spring security의  전체 프로세스
		: UsernamePasswordAuthenticationFilter 
			: 해당 url 에 접근 권한이 없는 경우 로그인 폼을 반환하는 얘임
				: 얘때문에 spring security 처음에 아무 설정안하면 로그인화면 뜨는거임

		1. 클라이언트 request 가 들어오고,  서블릿 필터에 도달
		2. 서블릿 필터의 request 를 security filter , 그 중에서도 UsernamePasswordAuthenticationFilter ( 이하 AuthenticationFilter )가 가로챔
		3. AuthenticationFilter 에서 username 과 password 를 추출해 UsernameAuthenticationToken(이하 인증객체) 를 생성
		4. AuthenticationFilter에서 AuthenticationManager (구현체 : ProviderManager) 에게 인증 객체를 전달
		5. ProviderManager 는 인증을 위해 AuthenticationProvider에게 인증 객체를 전달
		6. AuthenticationProvider 는 전달받은 인증객체의 정보(일반적으로 사용자id)를 UserDetailsService 에 넘김
		7. UserDetailsService에서 db 뒤져서 해당 사용자 정보와 일치하는 UserDetails객체를 AuthenticationProvider에 반환
		8. AuthenticationProvider은 반환받은 UserDetails를 인증하고, 성공하면 ProviderManager에게 권한 (Authorities) 을 담은 검증된 인증 객체를 반환

		9. ProviderManager는 검증된 인증 객체를 (event 기반 으로) AuthenticationFilter에게 반환
		10. AuthenticationFilter는 검증된 인증 객체를 SecurityContextHolder의 SecurityContext에 저장.

	: jwt 를 사용하는 spring security 의 전체 프로세스
		: UsernamePasswordAuthenticationFilter의 앞에 커스텀JWT인증필터(JwtAuthenticationFilter) 를 배치하여 권한 처리를 하게 된다.
		:  JwtTokenProvider >> Jwt Token을 생성, 인증, 권한 부여, 유효성 검사 등의 다양한 기능을 제공하는 클래스
			: JwtAuthenticationFilter 내부에서 주로 쓰임
			: JwtUtil 등의 네이밍도 괜춘
			
		: JwtAuthenticationFilter >> 
			doFilter 오버라이드
				: AuthenticationManager가 아닌 직접 커스텀한 JwtTokenProvider를 통해서 인증 후 SecurityContextHolder 에 authentication 저장
				: 마지막으로 chain.doFilter(request,response); 해서 다음 필터로 넘기기

		: CustomUserDetailsService >>> 
			:  인터페이스인 UserDetailsService를 상속받아 작성한 클래스로 JwtTokenProvider가 제공한 사용자 정보를 이용하여 DB에서 알맞은 사용자 정보를 가져와 UserDetails 생성
			: loadUserByUsername 오버라이드

		: CustomUser
			: User를 상속받아 작성한 클래스로 userName, password, authorities + a 를 제공
			: 대부분의 경우 Spring Security의 기본 UserDetails로는 필요한 정보를 모두 담을 수 없기에 CustomUser를 구현하여 사용한다.

			case1 : 토큰 발급이 안되어있을 경우
				1. 클라이언트 요청
				2. SecurityConfig에 등록된 JwtAuthenticationFilter 호출
				3. 토큰정보가 없기 때문에 다음 필터 호출

			case2 :  토큰을 발급하는 경우(로그인)
				1. 클라이언트 요청
				2. SecurityConfig에 등록된 JwtAuthenticationFilter 호출
				3. 토큰정보가 없기 때문에 다음 필터 호출
				4. UsernamePasswordAuthenticationFilter에서 로그인 폼 response 및 로그인 데이터를 받음
				5. UsernamePasswordAuthenticationFilter에서 사용자의 로그인id, pw를 사용하여 UsernamePasswordAuthenticationToken 객체 생성
				6. UsernamePasswordAuthenticationFilter에서 authenticationManagerBuilder를 이용하여 CustomUserDetailsService 의 loadUserByUsername 메소드 호출
				7. loadUserByUsername 의 반환값인 UserDetails 객체를 Authentication 타입의 객체로 반환
				8. Authentication을 이용하여 토큰 생성

			case3: 토큰 발급이 되어있는 경우
				1. 클라이언트 요청
				2. SecurityConfig에 등록된 JwtAuthenticationFilter 호출
				3. JwtAuthenticationFilter 에서 토큰 유효성 검사 후 통과되면 다음 필터 호출

		: https://velog.io/@jeon0728/Spring-Security-JWT-%EC%88%9C%EC%84%9C





	: 인증객체
		: principal >> 최상위 인터페이스
		: Authentication >> principal 을 상속한 인터페이스
			: Principal 과 GrantAuthority를 제공
				: 대부분의 경우 Principal로 UserDetails 반환함. 이 정보는 @AuthenticationPrincipal 어노테이션을 통해 컨트롤러에서 사용 가능하며, 필요할 경우 UserDetails를 상속받아 커스텀하여 추가 정보 저장
				: GrantAuthority >> ROLE_ADMIN, ROLE_USER등 Principal이 가지고 있는 권한 나타냄
					: prefix로 ‘ROLE_’ 이 붙음
					: 인증 이후에 인가를 할 때 사용. 권한은 여러개일 수 있으므로 Collection형태로 제공

		: AbstractAuthenticationToken >> Autentication 을 상속한 추상 클래스

		: UsernamePasswordAuthenticationToken >> AbstractAuthenticationToken 의 구현 클라스

	: SecurityContext >> Authentication을 저장하고 있음
	: SecutiryContextHolder
		: SecurityContext 객체를 저장하고 감싸고 있는 wrapper 클래스
		: getContext() 전역 메소드를 제공하여 securityContext에 접근이 가능함
		: 기본적으로 THREADLOCAL


	: doFilter 와 doFilterInternal
		doFilter 메소드: 
			:  javax.servlet.Filter 인터페이스에 정의된 메소드로, 모든 서블릿 필터가 구현해야 하는 메소드
			: 클라이언트의 요청이 서블릿에 도달하기 전과 서블릿이 응답을 클라이언트에게 반환한 후에 호출됨. 
			:  FilterChain 객체를 매개변수로 받아 체인의 다음 필터로 요청을 전달하거나, 필터 처리 후 요청을 서블릿이나 다른 리소스로 전달하는 역할을 함

		doFilterInternal 메소드:
			: 스프링의 OncePerRequestFilter를 상속받는 필터들이 구현해야 하는 메소드로, 요청당 한 번만 실행되어야 하는 로직을 정의함.



	: pre-authentication 방식 >> 인증을 spring 외부에서 진행
		: 시스템 내 다른 모듈에 api 를 제공하거나 이미 인증된 사용자에 대해 api 를 제공하는 spring 모듈을 만들어야 할 경우 유용
		: AbstractPreAuthenticatedProcessingFilter를 이용해 구현
		: https://bitgadak.tistory.com/9


	: OncePerRequestFilter
		: http request (요청)하나당 딱 한번만 실행되는 filter
			: 그러니까 forward 같은게 발생하더라도 여러번 수행되지 않는다.
	
		: doFilter(request,response ); 
		: https://junyharang.tistory.com/378
		


https://velog.io/@crow/AuthenticationEntryPoint-%EC%9D%B4%ED%95%B4
