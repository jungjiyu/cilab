swagger
docker
crolling
flask



Knlab MSA -------------------------------------------------------------------------------------------------
 
개발 > 배포 > 운영
- 개발 : 필요한 걸 만들자
- 배포 : 많은 사람들에게 전달하자
- 운영 : 지속 가능하게 관리하자

DevOps : Development + Operation
	: 개발+  운영 을 결합하자는 것.
	: DevOps 엔지니어 >> 개발 및 운영에 대한 광범위한 지식을 갖춰야 하는 IT 전문가



인프라 :  서비스의 기반이 되는 구성 요소들의 집합( 서버, 스위치, 스토리지 같은 하드웨어 장비 +  운영체제(OS) 같은 소프트웨어 및 네트워크)


토폴로지 topology: 망구성방식 . 네트워크의 물리적인 구성 방식, 형상.
	: ex) 망형 , 트리형, 성형(star) ... 

프로토콜 protocol : 서로 다른 시스템에 있는 개체 간 데이터를 전송하는 통신 규약
	: 계층적구조(7 layer)로 정의되어있음
		application > HTTP , FTP , ..
		transport > tcp, udp
		 . . .

network protocol != network topology
	ex)) broadband network(광대역통신)는 사용자끼리 모두 다른 사용자와 연결 가능해서 매시형으로 "보이지만", 실제로는 wifi hub 와 같은 중앙 노드가 있어 가능한 것. 그러니까 논리적으로는 풀매시일 지라도, 실제로는 풀 매시가 아닐 수 있다.





Mesh >> 그물망.
Mesh 네트워크 >> 네트워크 장치가 그물망처럼 연결되어 하나의 큰 네트워크를 이루는것. topology
	: 메시 네트워크를 이루는 장치들은 각각 "노드" 라고 부름
		: 각 노드는 다른 노드들에 대해 여러 경로를 가짐(다양한 경로로 접근 가능)
		: full mesh network >> 모든 노드가 다른 노드에 "직접" 연결됨. 모두 "직접" 통신 가능
		: partial mesh network >> 일부 노드들만 직접적으로 연결됨.
	: 유선(wire) 일 수도 , 무선(wireless)일 수도 있음


리피터 >> 먼 거리의 기계들 간 통신 중계를 해줌. 언제든 다른 디바이스의 신호를 중계할 준비가 되어있어야되서 대체로 배터리가 아닌 상시 전원을 사용
	: 무선 장치는 철근 과 같은 구조물과 다른 무선 장치로부터 전파 간섭을 받을 수 있다. 구조물의 영향을 덜 받고 전파간섭을 줄이기 위해 리피터를 설치 할 수 있다.
				

모듈 : 독립적으로 실행 가능한 단위.

응집도Cohesion: 모듈에 포함된 내부 요소들이 서로 연관된 정도
	: 높을 수록 좋다

결합도 Coupling: 다른 모듈과의 의존성 정도
	: 낮을 수록 좋다



 Composition, Aggregation, Delegation 
	: Composition ) Has-a 관계.  A, B 관계에서 A 가 B 를 포함하고 있고, A 가 사라진다면 포함하고 있는 B 도 같이 사라지는것
	: Aggregation ) 집합. Is-Part-Of 관계. A 가 B 의 집합의 개념이기 때문에 A 가 사라지더라도 B 는 사라지지 않는다.
		: 레고로 만들어진 집이 있다고할 때 이 집이 없어진다고해서 레고까지 없어지는게 아니다
	: Delegation )  위임. 특정 클래스의 역할을 또 다른 클래스에게 위임하는 구조
 
	: https://ch4njun.tistory.com/275





DIP Dependency Inversion Principle 의존성 역전 원칙
	: 객체에서 어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, 그 Class를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙이다.
	: 왜 >> 하위 요소를 직접적으로 사용하면  구체적인 내용에 클라이언트가 의존하게 되어 하위 요소에 변화가 있을 때마다 코드를 자주 수정해야 되기 때문이다.




DDD(Domain-Driven Design) 도메인 주도 설계 : 비즈니스 도메인별로 나눠 설계하고, 도메인들이 상호작용하게 하는 것.
	: : https://dev-coco.tistory.com/166
	: Domain 도메인 == 사건이 발생하는 집합, 영역
	: DDD 에서의 Domain > 비즈니스 도메인. 유사한 로직의 집합.
		ex )  쇼핑몰 --> 손님들이 주문하는 도메인 + 직원입장에선 옷들을 관리하는 도메인 + 결제를 담당하는 도메인

	: 주요 목표 >> 변경과 확장에 유리
		1. High cohesion : 높은 응집도.				
		2. Loosely coupling : 낮은 결합도.



 DDD의 Layered Architecuture (계층구조)
	: https://velog.io/@hyun6ik/Layer-%EA%B3%84%EC%B8%B5
	: 수직적 구조 : 상위 계층에서 하위계층으로의 접근은 가능하나 하위 계층에서는 상위 계층으로의 접근이 불가
	: 일반적으로 3 계층 또는 4 계층으로 나눔
		3계층 >> 표현계층(Presentation Layer) - 서비스계층(Business Layer) - 영속성계층(Persistence Layer)
	*******4계층 >>
			(1) 표현계층 Presentation Layer : 클라이언트의 request 를 받고 , response 하는 계층
				: controller, DTO, Mapper(converter)

			(2) 응용계층 Application Layer :  transaction등으로 묶여야 하는 로직을 aggregation 하는(집합화 하는 . 묶는. ) 역할을 한다.
				: Facade
					: 해당 Layer의 클래스 네이밍은 xxxFacade로 한다.
					: Facade 파사드>>  건물 정면, 외관. 클래스라이브러리 같은 소프트웨어의 커다란 코드 부분에 대해 간략화된 인터페이스픞 제공하는 객체.


			(3) 도메인 계층 Domain Layer : 비즈니스 로직에 대한 정보, 규칙을 표현하고 , 흐름을 제어한다. 세부 구현은 인프라 레이어에 위임한다.
				: Entity, Sevice (interface), ServiceImpl,  Factory(interface)
					: 주요 도메인 흐름을 관리하는 인터페이스 하나만 XXXService.java 로 정의하고, 이를 서포트 해주는 다른 서비스 인터페이스들은 XXXService 이외의 네이밍으로 정의한다.
							ex )  XxxxReader , XxxxExecutor , XxxxFactory ... 
					: XXXService 인터페이스만 이 레이어에서 구현(XXXServiceImpl )하고, 이외의 선언한 서비스 인터페이스 구현( XXXXImpl)은 infrastructure 에서 한다. 
					: 서비스 인터페이스들끼리는 되도록 참조관계를 가지지 않게 한다. 그런 코드는 가독성이 떨어진다.
						
				


			(4) 인프라 계층 Infrastructure Layer :domain layer 에서 선언된 interface 를 구현 .외부(DB, 메시징 시스템 등)와의 통신을 담당하는 계층.
				:  ReaderImpl, StoreImpl, Spring JPA, RedisConnector ... 
				
				: 서비스 인터페이스 간의 참조 관계는 막았지만, infrastructure layer에서의 구현체 간에는 참조 관계를 허용한다.
				:  @Service가 아닌 @Component를 활용한다.


	: 주요 목표 >>각각의 도메인들을 위와 같은 Layer로 철처히 분리해서 만드는 것


컴포넌트 == 재사용가능한 독립된 모듈.


API: 프로그램들이 서로 통신할 수 있게하는 매개체. 인터페이스.


end-point :   서비스에서 제공하는 커뮤니케이션 채널의 한쪽 끝.  서버의 리소스에 접근할 수 있도록 하는, 가장 최앞단 URL
	:https://blog.naver.com/ghdalswl77/222401162545




third party : 보조적인 소프트웨어/하드웨어 를 개발하는 회사.
	: 원천기술을 가진 회사를 의미하는 퍼스트 파티 와는 반대되는 개념
	

인증 Authentication : 유저가 "누구"인지 확인하는 절차	
인가 Authorization : 어떠한 유저가 특정 자원에 접근하려 할때, 그에대한 접근 "권한"이 있는지 확인하는 절차
	: 흐린눈하면 영어 철자가 비슷한데 잘 보면 확실히 다른 영단어임🤦‍♀️


오프로드 offload :  과부하를 방지하기 위해 코드 같은걸 다른 곳으로 옮긴것


legacy : 과거로부터 내려온 시스템/기술. 낡은 시스템/기술.
	: 직역함 유산


 Scale-out : 서버를 여러 대 추가하여 시스템을 확장하는 것.
 Scale-up :  기존 서버의 사양을 업그레이드해 시스템을 확장하는 것

----------------------------------------------------------------------------------------------------------

모노릭스 Monolithic >> 단일시스템
	: 화면, API, 회원 등 정보를 하나의 어플리케이션으로 구현한 것
	: 소규모 프로젝트일경우 합리적인방식. 일정 규모 이상은 MSA 써야.
	: 기존에 쓰던 방식
	: 문제점 > 강한 결합성으로 인해 일부에서 애러나도 전체적으로 에러가 발생된다
	

ESB Enterprise Service Bus
	:  서로 다른 애플리케이션 간의 실시간 데이터 교환을 지원하는 미들웨어.

SOA Service Oriented Architecture 서비스 지향 설계 방식
	: 서비스 단위로 개발을 하고, 개발된 서비스들을 공유함으로써 재가용성을 늘리고 유연성을 확보
	: 문제점  >> ESB
		1.  당시 ESB 내부 처리 로직을 XML을 기반으로 하였는데, XML의 파싱은 오버헤드가 큰 작업이었음
		2. , ESB는 가벼운 연산 뿐만 아니라, 과도한 Orchestration 등 무거운 로직을 가지고 있었음

	: MSA 와의 공통점 : 모두 서비스 지향 설계 방식.
	: MSA 와의 차이점
		: SOA > 비즈니스 측면에서의 서비스 재사용성을 중요시하고, ESB 라는 서비스 채널 이용하여 서비스를 공유 및 재사용. 즉 , 중앙집중형식. 서비스 간 공유 최대화. 결합도가 높음.  SOAP/XML 기반의 무거운 기능.
		: MSA > 한 가지 작은 서비스에 집중하여 서비스를 공유하지 않고 독립적인 실행을 함. 즉, 분산된 형식. 서비스 간 결합도를 낮추어 변화에 능동적으로 대응. Rest API 방식으로 통신.  REST/JSON 기반으로 보다 가볍게 설계.
	



MSA Micro Service Architecture
	: https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2-MSA-Outer-Architecure
	: Micro >>작다 !
	: 복잡한 웹 시스템에 맞춰 개발된 API 기반의 서비스 지향적인 아키텍쳐 스타일로,  스스로 돌아갈 수 있는 , 독립적 배포 가능한 서비스 단위로 쪼갠것( == 서비스를 모듈화한것). 즉, 큰 서비스를 잘게 쪼개어 개발/운영하는 아키텍쳐.
	: 인스턴스는 말 그대로 해당 마이크로서비스 클래스의 객체
	: 요즘에 각광받고있다
	: 왜 쪼겠나? 
		1. 장애가 나도 그부분만 장애가 생기는거지, 사이트 전체적으로 생기는게 아니다
		2. 부분적인 증/감 축 가능
		3. 부분적인 배포 가능

	: 단점 > 통신 복잡성 증가.
		: 그러니까 service 와 instance 가 증가한다. 

	: 특징 
		1. api 를 통해서만 msa 와 서비스가 상호작용 가능
			: 마이크로서비스는 서비스의 end-point 을 API 형태로 외부에 노출하고, 실질적인 세부 사항은 모두 추상화 해놓는다. 그러니까 내부 구현 로직은 모두 서비스 API 에 의해 가려진다.

		2. 다양한 언어로 구성 가능: 모든 것을 추상화하여 서비스 API 뒤에 숨기기 떄문에 서로 다른 마이크로 서비스에서 서로 다른 아키텍쳐 적용 가능

		3. 자동화 : msa 는 여러개의 작은 서비스로 분리하므로 상당히 많은 마이크로 서비스가 존재한다. 그렇기에 마이크로 서비스를 자동화하지 않는다면 관리부담이 커진다.

		4. 동적이고 "분산화"됨 : msa 는 soa 에서 사용되는 (중앙)집중화된 관리 체계를 사용하지 않는다


	: 구조
		Inner Architecture : 개별 마이크로 서비스 구축을 위한 아키텍쳐.  내부 서비스를 어케 잘 쪼개는가에 대한 아키텍쳐. >> 정해진 것은 없고 직접 결정해야.
			1. 마이크로 서비스를 어케 정의할 것인가? 그러니까 서비스를 얼마나 잘게 쪼갤것인가? ex) 쇼핑몰에서 주문하기와 카트에 넣기를 같은 서비스로 넣을 것인가?
			2. db access 구조를 어떻게 설계할 것인가? 그러니까 각 마이크로 서비스 단위로 모두 자체 db 를 가지게 할 것인가, 아님 일부 서비스는 같은 db 를 가지게 할 것인가? 
			3. 서비스 내 API 설계를 어떻게 할 것인가?

		Outer Architecture : 개별 마이크로 서비스가 개발/배포/실행되는 운영환경과 , 마이크로 서비스 관리 기능을 제공하는 아키텍처  
			: 구성 요소
			(1) API Gateway : API 서버 앞단에서 모든 API 서버들의 엔드포인트를 단일화해주는 또다른 서버
				: 기능
					1. API에 대한 인증/인가 기능 	
						: 각 마이크로서비스마다 인증/인가 처리 코드를 심어두면 소스의 중복이 심하고 유지보수가 어려웠겠지만 이걸 API Gateway 에서 일괄적으로 처리해준다.

					2. 요청절차 단순화 : 여러 서비스들에 대한 클라이언트의 요청들을, 단일 클라이언트의 요청으로 대체 가능하게함. 
						: 그러니까 클라이언트가 일일이 여러 서비스에게 다 요청하지 않고, 요청 하나만 보내도 여러 서비스에 요청한 효과를 낼 수 있음
					3. 메세지에 따라 해당 서버로 라우팅하는 기능
					4. 서비스 오케스트레이션 기능 제공
						오케스트레이션 orchestration : 여러 마이크로 서비스를 묶어 새로운 서비스를 만드는 개념.
							: 무턱대고 박으면 안되고 적절히 박아야

					5.  서비스 디스커버리 기능
						: Service Discovery >> 서비스의 위치(IP 주소와 포트번호)를 찾는 것
						: legacy 환경이 아닌 클라우드 환경에서는 유동 IP 주소를 가지기 때문에 그냥 알기는 힘들다. API gateway 에서는 Server Side 나 Client Side 를 기준으로 서비스 디스커버리가 가능하다.
	
				: 단점
					1. API Gateway가 내부 마이크로서비스와 결합된다는 것. 이는 SOA 의 ESB 에서 발생했던 문제를 일으킬 수 있따
					2. API Gateway라는 추가적인 계층이 만들어지는 것이기 때문에, 그만큼 네트워크 latency가 증가

			(2) Service Mesh : 마이크로서비스 구성 요소(서비스)간의 통신(네크워크) 를 담당
				: 통신 및 네트워크 기능을 비즈니스 로직과 분리한 네트워크 통신 인프라
				: MSA 가 유발하는 문제점(복잡성)을 보완한다.
				: MicroService Architecture 를 적용한 시스템의 내부 "통신"이 Mesh 네트워크 형태(망형태)를 띄는것에 빗대어 이름이 붙여진것.
				: 보통 서비스의 앞단에 경량화 프록시를 "사이드카 패턴"으로 배치하여, 공통기능처리를 분산화 하여 서비스 간 통신을 제어하는 방법으로 구현됨.
					: 사이드 카 패턴 >> 원래 사용하려고 했던 기본 컨테이너의 기능을 확장하거나 보조하는 용도의 컨테이너를 추가하는 패턴 .  부가 기능을 별도의 application 으로 구현하고 이를 핵심 application 과 동일한 프로세스 또는 컨테이너 내부에 배치하는 것.
						: 클라우드 디자인 패턴(쿠버네티스 패턴)의 일종. 
						: 장점 ) side car application 은 핵심(기본) application 과 별도의 application이 >> 기본 applicatino 
					: proxy 에 routing rules, timeout 등을 설정하고 로직을 작성하여 공통 기능을 기본 어플리케이션에서 분리시킬 수 있다.

				: https://medium.com/dtevangelist/service-mesh-%EB%9E%80-8dfafb56fc07

			(3) Container Management : 컨테이너 기반 어플리케이션 운영
				: 유연성과 자율성을 가지며 개발자가 손쉽게 접근 및 운영할 수 있는 인프라 관리 기술
				
			(4) Backing Service: 데이터의 지속성과 일관성 있는 처리를 위해 동작
				: 어플리케이션 실행 중 네트워크를 통해 사용할 수 있는 모든 서비스. mySQL ,  Message queue 등 애플리케이션과 통신하는 attached Resource 들을 지칭하는 포괄적 개념
				:  특징적인 Backing service들 중 하나는 Message queue >> MSA 에서는 메세지의 송신자와 수신자가 직접 통신하지 ㅏㅇㄶ고 Message Queue 를 활용해 "비동기"적으로 통신하는 것을 "지향"
					ex ) MSA 프젝에서 장애가 발생하면 , MicroService 오케스트레이션이 진행되면서, 새로은 MIcroService 를 신규생성하는 등의 작업을 진행하게 된다.
						: 오케스트레이션(orchestration) >> 오케스트레이터(orchestrator) 라는 중앙 컨트롤러가 보상 작업을 트리거하는(일으키는) 방식이다.

				: 마이크로 서비스간의 결합도를 줄여준다
				: Banking Service 를 사용하지 않았을 떄의 문제점.
					: Message Queue 를 사용하지 않는 강한 결합 구조는 여러 서비스를 거치는 실시간 트랜잭션을 처리할 떄, 하나의 서비스가 죽어버리면 트랜잭션이 끊어지기 떄문에 해당 서비스 요청을 보존할 수 없고 큰 에러가 발생하게 됨.
					: REST 통신으로 트랜잭션 실패에 대한 처리를 구현하는 방법은 굉장히 복잡합니다.

			(5) Telemetry >> 실시간으로 먼 거리에서 원격으로 측정할 수 있다 .. .
				: Tele(먼 거리) + metry(측정)
				: 상당수의 마이크로서비스가 분산환경에서 운영되기 떄문에 서비스들의 상태를 일일이 모니터링하고 대응하는 것은 어려움. Telemtry는 서비스들을 모니터링하고, 서비스 별로 발생하는 이슈들에 대응할 수 있도록 환경을 구성하는 역할을 함.

			(6) CI/CD Automation :  CI 와 CD를 자동화하여, 어플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법
				: CI Continuous Integeration 지속적인 통합
				: CD Continuous Delivery 지속적 전달, CD Continous Deployment 지속적인 배포

	: https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e


----------------------------------------------------------------------------------------------------------



NAS  Network Attached Storage 란
	: 네트워크 결합 저장장치. 네트워크가 되는 외장하드
	: 데이터 저장과 공유 목적
	: OS 제약도 따로 없고, 인터넷이 되는 곳이면 어디서든 접근 가능.

	: 클라우드와의 차이점
		비용  >> 클라우드는 월정액 방식, NAS는 초기투자비용은 좀 들지만, 이후 비용은 거의 안든다. 
	******용량 >>클라우드에 비해 NAS가 용량 널널함. 2TB 이상 쓸꺼면 NAS 써야됨
		속도 >> NAS가 클라우드 보다 대체적으로 빠름
		서버의 안전성 >> 개인이 아닌 대규모로 운영되는 클라우드가 NAS 보다 더 안정적. (휴지통, 서버 해킹)
		계정 자체의 보안성 >> 클라우드 보다 NAS 가 개인정보 유출에 강함
		




하나의 api gateway 를 통하여 외부와 통신
	: 해당 gateway 는 내부적으로 Auth Server , Admin Server  , Document Server , Common Server 과 연결되어있음.
		(1) Auth Server
			: MySQL 의 Auth 에 유일하게 접근 가능

		(2) Admin Server
			: Admin Server 에서 Common Server 쪽으로 갈 수 있다
			: NAS Server 에 유일하게 접근 가능
			: MySQL 의 Crawl Info 에 유일하게 접근 가능하다

		(3) Document Server
			: ElasticSearch 전체(politica, screening,project), MySQL 의 Document Meta 에 접근 가능하다.

		(4) Common Server
			: ElasticSearch 전체(politica, screening,project), MySQL 의 Document Meta 와 Common에 접근 가능



db 는 MySQL 과 ElasticSearch 를 사용
	MySQL
		Auth
		Document Meta
		Crawl Info
		Common

	ElasticSearch
		Politica
		Screening
		Project


nextrend -------------------------------------------------------------------------------------------------



