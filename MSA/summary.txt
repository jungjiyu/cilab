----------------------------------------------------------------------------------------------------------

 
개발 > 배포 > 운영
- 개발 : 필요한 걸 만들자
- 배포 : 많은 사람들에게 전달하자
- 운영 : 지속 가능하게 관리하자
----------------------------------------------------------------------------------------------------------

nanoId : DB와 같은 곳에 랜덤 문자열로 ID를 생성해야하는 경우 사용한다
	: 고유하고 짧은 URL 친화적인 식별자를 생성하기 위한 JavaScript 라이브러리
	: 대문자와 소문자, 숫자를 포함하는 더 넓은 폭의 알파벳을 사용하며, 하이픈과 같은 구분 기호는 사용하지 않는다.
	: UUID보다 빠르다
	: https://velog.io/@kwontae1313/npm-nanoid-%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90

----------------------------------------------------------------------------------------------------------
스크리닝 screening : 걸러내기, 선별하기.
----------------------------------------------------------------------------------------------------------

DevOps : Development + Operation
	: 개발+  운영 을 결합하자는 것.
	: DevOps 엔지니어 >> 개발 및 운영에 대한 광범위한 지식을 갖춰야 하는 IT 전문가



인프라 :  서비스의 기반이 되는 구성 요소들의 집합( 서버, 스위치, 스토리지 같은 하드웨어 장비 +  운영체제(OS) 같은 소프트웨어 및 네트워크)

----------------------------------------------------------------------------------------------------------

토폴로지 topology: 망구성방식 . 네트워크의 물리적인 구성 방식, 형상.
	: ex) 망형 , 트리형, 성형(star) ... 

프로토콜 protocol : 서로 다른 시스템에 있는 개체 간 데이터를 전송하는 통신 규약
	: 계층적구조(7 layer)로 정의되어있음
		application > HTTP , FTP , ..
		transport > tcp, udp
		 . . .

network protocol != network topology
	ex)) broadband network(광대역통신)는 사용자끼리 모두 다른 사용자와 연결 가능해서 매시형으로 "보이지만", 실제로는 wifi hub 와 같은 중앙 노드가 있어 가능한 것. 그러니까 논리적으로는 풀매시일 지라도, 실제로는 풀 매시가 아닐 수 있다.



----------------------------------------------------------------------------------------------------------


Mesh >> 그물망.
Mesh 네트워크 >> 네트워크 장치가 그물망처럼 연결되어 하나의 큰 네트워크를 이루는것. topology
	: 메시 네트워크를 이루는 장치들은 각각 "노드" 라고 부름
		: 각 노드는 다른 노드들에 대해 여러 경로를 가짐(다양한 경로로 접근 가능)
		: full mesh network >> 모든 노드가 다른 노드에 "직접" 연결됨. 모두 "직접" 통신 가능
		: partial mesh network >> 일부 노드들만 직접적으로 연결됨.
	: 유선(wire) 일 수도 , 무선(wireless)일 수도 있음

----------------------------------------------------------------------------------------------------------

리피터 >> 먼 거리의 기계들 간 통신 중계를 해줌. 언제든 다른 디바이스의 신호를 중계할 준비가 되어있어야되서 대체로 배터리가 아닌 상시 전원을 사용
	: 무선 장치는 철근 과 같은 구조물과 다른 무선 장치로부터 전파 간섭을 받을 수 있다. 구조물의 영향을 덜 받고 전파간섭을 줄이기 위해 리피터를 설치 할 수 있다.

----------------------------------------------------------------------------------------------------------
				

모듈 : 독립적으로 실행 가능한 단위.

응집도Cohesion: 모듈에 포함된 "내부" 요소들이 서로 "연관"된 정도
	: 높을 수록 좋다

결합도 Coupling: "다른" 모듈과의 "의존성" 정도
	: 낮을 수록 좋다


----------------------------------------------------------------------------------------------------------

 Composition, Aggregation, Delegation 
	: Composition ) Has-a 관계.  A, B 관계에서 A 가 B 를 포함하고 있고, A 가 사라진다면 포함하고 있는 B 도 같이 사라지는것
	: Aggregation ) 집합. Is-Part-Of 관계. A 가 B 의 집합의 개념이기 때문에 A 가 사라지더라도 B 는 사라지지 않는다.
		: 레고로 만들어진 집이 있다고할 때 이 집이 없어진다고해서 레고까지 없어지는게 아니다
	: Delegation )  위임. 특정 클래스의 역할을 또 다른 클래스에게 위임하는 구조
 
	: https://ch4njun.tistory.com/275



----------------------------------------------------------------------------------------------------------


DIP Dependency Inversion Principle 의존성 역전 원칙
	: 객체에서 어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, 그 Class를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙이다.
	: 왜 >> 하위 요소를 직접적으로 사용하면  구체적인 내용에 클라이언트가 의존하게 되어 하위 요소에 변화가 있을 때마다 코드를 자주 수정해야 되기 때문이다.


----------------------------------------------------------------------------------------------------------


DDD(Domain-Driven Design) 도메인 주도 설계 : 비즈니스 도메인별로 나눠 설계하고, 도메인들이 상호작용하게 하는 것.
	: : https://dev-coco.tistory.com/166
	: Domain 도메인 == 사건이 발생하는 집합, 영역
	: DDD 에서의 Domain > 비즈니스 도메인. 유사한 로직의 집합.
		ex )  쇼핑몰 --> 손님들이 주문하는 도메인 + 직원입장에선 옷들을 관리하는 도메인 + 결제를 담당하는 도메인

	: 주요 목표 >> 변경과 확장에 유리
		1. High cohesion : 높은 응집도.				
		2. Loosely coupling : 낮은 결합도.



 DDD의 Layered Architecuture (계층구조)
	: https://velog.io/@hyun6ik/Layer-%EA%B3%84%EC%B8%B5
	: 수직적 구조 : 상위 계층에서 하위계층으로의 접근은 가능하나 하위 계층에서는 상위 계층으로의 접근이 불가
	: 일반적으로 3 계층 또는 4 계층으로 나눔
		3계층 >> 표현계층(Presentation Layer) - 서비스계층(Business Layer) - 영속성계층(Persistence Layer)
	*******4계층 >>
			(1) 표현계층 Presentation Layer : 클라이언트의 request 를 받고 , response 하는 계층
				: controller, DTO, Mapper(converter)

			(2) 응용계층 Application Layer :  transaction등으로 묶여야 하는 로직을 aggregation 하는(집합화 하는 . 묶는. ) 역할을 한다.
				: Facade
					: 해당 Layer의 클래스 네이밍은 xxxFacade로 한다.
					: Facade 파사드>>  건물 정면, 외관. 클래스라이브러리 같은 소프트웨어의 커다란 코드 부분에 대해 간략화된 인터페이스픞 제공하는 객체.


			(3) 도메인 계층 Domain Layer : 비즈니스 로직에 대한 정보, 규칙을 표현하고 , 흐름을 제어한다. 세부 구현은 인프라 레이어에 위임한다.
				: Entity, Sevice (interface), ServiceImpl,  Factory(interface)
					: 주요 도메인 흐름을 관리하는 인터페이스 하나만 XXXService.java 로 정의하고, 이를 서포트 해주는 다른 서비스 인터페이스들은 XXXService 이외의 네이밍으로 정의한다.
							ex )  XxxxReader , XxxxExecutor , XxxxFactory ... 
					: XXXService 인터페이스만 이 레이어에서 구현(XXXServiceImpl )하고, 이외의 선언한 서비스 인터페이스 구현( XXXXImpl)은 infrastructure 에서 한다. 
					: 서비스 인터페이스들끼리는 되도록 참조관계를 가지지 않게 한다. 그런 코드는 가독성이 떨어진다.
						
				


			(4) 인프라 계층 Infrastructure Layer :domain layer 에서 선언된 interface 를 구현 .외부(DB, 메시징 시스템 등)와의 통신을 담당하는 계층.
				:  ReaderImpl, StoreImpl, Spring JPA, RedisConnector ... 
				
				: 서비스 인터페이스 간의 참조 관계는 막았지만, infrastructure layer에서의 구현체 간에는 참조 관계를 허용한다.
				:  @Service가 아닌 @Component를 활용한다.


	: 주요 목표 >>각각의 도메인들을 위와 같은 Layer로 철처히 분리해서 만드는 것

----------------------------------------------------------------------------------------------------------


컴포넌트 == 재사용가능한 독립된 모듈.

----------------------------------------------------------------------------------------------------------

API: 프로그램들이 서로 통신할 수 있게하는 매개체. 인터페이스.


end-point :   서비스에서 제공하는 커뮤니케이션 채널의 한쪽 끝.  서버의 리소스에 접근할 수 있도록 하는, 가장 최앞단 URL
	:https://blog.naver.com/ghdalswl77/222401162545


----------------------------------------------------------------------------------------------------------


third party : 보조적인 소프트웨어/하드웨어 를 개발하는 회사.
	: 원천기술을 가진 회사를 의미하는 퍼스트 파티 와는 반대되는 개념
	
----------------------------------------------------------------------------------------------------------

인증 Authentication : 유저가 "누구"인지 확인하는 절차	
인가 Authorization : 어떠한 유저가 특정 자원에 접근하려 할때, 그에대한 접근 "권한"이 있는지 확인하는 절차
	: 흐린눈하면 영어 철자가 비슷한데 잘 보면 확실히 다른 영단어임🤦‍♀️

----------------------------------------------------------------------------------------------------------

오프로드 offload :  과부하를 방지하기 위해 코드 같은걸 다른 곳으로 옮긴것

----------------------------------------------------------------------------------------------------------

legacy : 과거로부터 내려온 시스템/기술. 낡은 시스템/기술.
	: 직역함 유산
----------------------------------------------------------------------------------------------------------


 Scale-out : 서버를 여러 대 추가하여 시스템을 확장하는 것.
 Scale-up :  기존 서버의 사양을 업그레이드해 시스템을 확장하는 것

----------------------------------------------------------------------------------------------------------


사이드 카 패턴 >> 원래 사용하려고 했던 기본 컨테이너의 기능을 확장하거나 보조하는 용도의 컨테이너를 추가하는 패턴 .  부가 기능을 별도의 application 으로 구현하고 이를 핵심 application 과 동일한 프로세스 또는 컨테이너 내부에 배치하는 것.
	: 클라우드 디자인 패턴(쿠버네티스 패턴)의 일종. 

----------------------------------------------------------------------------------------------------------


웹서버에서 요청을 처리하는 법
	: https://velog.io/@onejaejae/%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B9%84%EB%8F%99%EA%B8%B0-IO-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BB%A4%EB%AE%A4%EB%8B%88%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B9%84%EB%8F%99%EA%B8%B0asynchronous
	: https://kimdeveloper.tistory.com/2
	: 동기방식 >> 웹서버에 클라이언트로부터 들어온 요청 당 스레드 혹은 프로세스를 할당하여 처리하는 방법		
		: 결합도가 높다. 유연성이 낮다.
		: 단점
			1. 요청의 갯수만큼 쓰레드를 생성하기에 쓰레드가 너무 많이 생성됨
			2. 입출력처리가 끝날때까지 스레드가 메모리버퍼에 데이터를 차지하여 입출력을 결과를 기다리는 것 만으로 메모리를 잡아먹기에 비효율적
		: 근데 뭐 서버 사양이 넉넉해 많은 스레드 감당할 수 있는 경우 사용해라


	: 비동기방식>> 요청을 받는 스레드와 요청에 대해 처리하는 스레드를 따로 두는 방식
		: 결합도가 낮다. 유연하다.
		: 요청을 받는 스레드에서는 요청을 blocking없이 지속적으로 받으면서 입출력이 필요한 요청은 요청을 처리하는 스레드로 따로 보내놓고 입출력 처리가 끝났을때 결과를 따로 클라이언트에게 리턴	
		: 요청에 따라 스레드를 새로 생성하는 것이 아니기에 동기방식에 비해서 메모리 점유율이 낮다. 입출력 작업이 이루어지는 동안 메모리를 점유하지 않는다.


----------------------------------------------------------------------------------------------------------

OSS Open Source Software : 오픈소스소프트웨어

----------------------------------------------------------------------------------------------------------

(서버) 클러스터 Cluster :  서버를 여러대 연결하여 하나의 시스템처럼 동작하는것
	: 클러스터로 묶인 한시스템에 장애가 발생하면, 정보의 제공 포인트는 클러스터로 묶인 다른 정상적인 서버로 이동한다. 서버클러스터는 사용자로 하여금 서버 기반 정보를 지속적이고, 끊기지않게 제공받을수 있게 한다.
	: https://allpartner.tistory.com/11

----------------------------------------------------------------------------------------------------------
Hash 와 Salt  >> 암호화 방식
	: https://st-lab.tistory.com/100
----------------------------------------------------------------------------------------------------------
모노릭스 Monolithic >> 단일시스템
	: 화면, API, 회원 등 정보를 하나의 어플리케이션으로 구현한 것
	: 소규모 프로젝트일경우 합리적인방식. 일정 규모 이상은 MSA 써야.
	: 기존에 쓰던 방식
	: 문제점 > 강한 결합성으로 인해 일부에서 애러나도 전체적으로 에러가 발생된다
	

ESB Enterprise Service Bus
	:  서로 다른 애플리케이션 간의 실시간 데이터 교환을 지원하는 미들웨어.

SOA Service Oriented Architecture 서비스 지향 설계 방식
	: 서비스 단위로 개발을 하고, 개발된 서비스들을 공유함으로써 재가용성을 늘리고 유연성을 확보
	: 문제점  >> ESB
		1.  당시 ESB 내부 처리 로직을 XML을 기반으로 하였는데, XML의 파싱은 오버헤드가 큰 작업이었음
		2. , ESB는 가벼운 연산 뿐만 아니라, 과도한 Orchestration 등 무거운 로직을 가지고 있었음

	: MSA 와의 공통점 : 모두 서비스 지향 설계 방식.
	: MSA 와의 차이점
		: SOA > 비즈니스 측면에서의 서비스 재사용성을 중요시하고, ESB 라는 서비스 채널 이용하여 서비스를 공유 및 재사용. 즉 , 중앙집중형식. 서비스 간 공유 최대화. 결합도가 높음.  SOAP/XML 기반의 무거운 기능.
		: MSA > 한 가지 작은 서비스에 집중하여 서비스를 공유하지 않고 독립적인 실행을 함. 즉, 분산된 형식. 서비스 간 결합도를 낮추어 변화에 능동적으로 대응. Rest API 방식으로 통신.  REST/JSON 기반으로 보다 가볍게 설계.
	



MSA Micro Service Architecture
	: https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2-MSA-Outer-Architecure
	: Micro >>작다 !
	: 복잡한 웹 시스템에 맞춰 개발된 API 기반의 서비스 지향적인 아키텍쳐 스타일로,  스스로 돌아갈 수 있는 , 독립적 배포 가능한 서비스 단위로 쪼갠것( == 서비스를 모듈화한것). 즉, 큰 서비스를 잘게 쪼개어 개발/운영하는 아키텍쳐.
	: 인스턴스는 말 그대로 해당 마이크로서비스 클래스의 객체
	: 요즘에 각광받고있다
	: 왜 쪼겠나? 
		1. 장애가 나도 그부분만 장애가 생기는거지, 사이트 전체적으로 생기는게 아니다
		2. 부분적인 증/감 축 가능
		3. 부분적인 배포 가능

	: 단점 > 통신 복잡성 증가.
		: 그러니까 service 와 instance 가 증가한다. 

	: 특징 
		1. api 를 통해서만 msa 와 서비스가 상호작용 가능
			: 마이크로서비스는 서비스의 end-point 을 API 형태로 외부에 노출하고, 실질적인 세부 사항은 모두 추상화 해놓는다. 그러니까 내부 구현 로직은 모두 서비스 API 에 의해 가려진다.

		2. 다양한 언어로 구성 가능: 모든 것을 추상화하여 서비스 API 뒤에 숨기기 떄문에 서로 다른 마이크로 서비스에서 서로 다른 아키텍쳐 적용 가능

		3. 자동화 : msa 는 여러개의 작은 서비스로 분리하므로 상당히 많은 마이크로 서비스가 존재한다. 그렇기에 마이크로 서비스를 자동화하지 않는다면 관리부담이 커진다.

		4. 동적이고 "분산화"됨 : msa 는 soa 에서 사용되는 (중앙)집중화된 관리 체계를 사용하지 않는다


	: 구조
		Inner Architecture : 개별 마이크로 서비스 구축을 위한 아키텍쳐.  내부 서비스를 어케 잘 쪼개는가에 대한 아키텍쳐. >> 정해진 것은 없고 직접 결정해야.
			1. 마이크로 서비스를 어케 정의할 것인가? 그러니까 서비스를 얼마나 잘게 쪼갤것인가? ex) 쇼핑몰에서 주문하기와 카트에 넣기를 같은 서비스로 넣을 것인가?
			2. db access 구조를 어떻게 설계할 것인가? 그러니까 각 마이크로 서비스 단위로 모두 자체 db 를 가지게 할 것인가, 아님 일부 서비스는 같은 db 를 가지게 할 것인가? 
			3. 서비스 내 API 설계를 어떻게 할 것인가?

		Outer Architecture : 개별 마이크로 서비스가 개발/배포/실행되는 운영환경과 , 마이크로 서비스 관리 기능을 제공하는 아키텍처  
			: 구성 요소
			(1) API Gateway || External Gateway : API 서버 앞단에서 모든 API 서버들의 엔드포인트를 단일화해주는 또다른 서버
				: 기능
					1. API에 대한 인증/인가 기능 	
						: 각 마이크로서비스마다 인증/인가 처리 코드를 심어두면 소스의 중복이 심하고 유지보수가 어려웠겠지만 이걸 API Gateway 에서 일괄적으로 처리해준다.

					2. 요청절차 단순화 : 여러 서비스들에 대한 클라이언트의 요청들을, 단일 클라이언트의 요청으로 대체 가능하게함. 
						: 그러니까 클라이언트가 일일이 여러 서비스에게 다 요청하지 않고, 요청 하나만 보내도 여러 서비스에 요청한 효과를 낼 수 있음
					3. 메세지에 따라 해당 서버로 라우팅하는 기능
					4. 서비스 오케스트레이션 기능 제공
						오케스트레이션 orchestration : 여러 마이크로 서비스를 묶어 새로운 서비스를 만드는 개념.
							: 무턱대고 박으면 안되고 적절히 박아야

					5.  서비스 디스커버리 기능
						: Service Discovery >> 서비스의 위치(IP 주소와 포트번호)를 찾는 것
						: legacy 환경이 아닌 클라우드 환경에서는 유동 IP 주소를 가지기 때문에 그냥 알기는 힘들다. API gateway 에서는 Server Side 나 Client Side 를 기준으로 서비스 디스커버리가 가능하다.
	
				: 단점
					1. API Gateway가 내부 마이크로서비스와 결합된다는 것. 이는 SOA 의 ESB 에서 발생했던 문제를 일으킬 수 있따
					2. API Gateway라는 추가적인 계층이 만들어지는 것이기 때문에, 그만큼 네트워크 latency가 증가

				: 일반적으로  Gateway proxy pattern을 사용해서 수행 
					: Gateway proxy pattern >>  Consumer(호출자)은 구현 내용을 알 필요 없이 Gateway를 호출하면,  Gateway가 알아서 수행해주는 방식

			(2) Service Mesh : 마이크로서비스 구성 요소(서비스)간의 통신(네크워크) 를 담당
				: MSA 가 유발하는 문제점(복잡성)을 보완한다.
				: MicroService Architecture 를 적용한 시스템의 내부 "통신"이 Mesh 네트워크 형태(망형태)를 띄는것에 빗대어 이름이 붙여진것.
				: 유형

				******(1) Sidecar proxy pattern을 사용 
						: Istio/Envoy, Consul, Linkerd 등
						: 각 마이크로 서비스의 앞단에 경량화 프록시를 "사이드카 패턴"으로 배치한다
							: 사이드 카 패턴 >> 원래 사용하려고 했던 기본 컨테이너의 기능을 확장하거나 보조하는 용도의 컨테이너를 추가하는 패턴 .  부가 기능을 별도의 application 으로 구현하고 이를 핵심 application 과 동일한 프로세스 또는 컨테이너 내부에 배치하는 것.
								: 클라우드 디자인 패턴(쿠버네티스 패턴)의 일종. 
						:효과
							1. 비즈니스 로직과 통신/네트워크 관리 기능을 분리
							2. 서비스 호출 시 직접 서비스가 호출되는 것이 아니라 proxy 를 통해서 호출하게됨



					(2) PaaS (Platform As A Service)의 일부로 서비스 코드에 포함
						: Microsoft Azure Service fabric, lagom, SENECA 등
						: 프레임워크 기반의 프로그래밍 모델이기 때문에, 서비스메쉬를 구현하는데에 특화된 코드가 필요. ( Mesh-native Code )


					(3) 라이브러리로 구현되어 API 호출을 통해 Service mesh에 결합
						: Spring Cloud, Netflix OSS(Ribbon/Hystrix/Eureka/Archaius), finagle 등
						: 프레임워크 라이브러리를 사용하는 형태. 이중 Netfilix의 Prana는 sidecar 형태로 동작. 서비스 메시를 이해하고 코드를 작성해야함. (Mesh Aware Code)

				: API Gateway는 마이크로서비스 그룹의 외부 경계에 위치하여 역할을 수행하지만, ServiceMesh는 내부에서 그 역할을 수행한다.

				: https://medium.com/dtevangelist/service-mesh-%EB%9E%80-8dfafb56fc07

			(3) Container Management : 컨테이너 기반 어플리케이션 운영
				: 유연성과 자율성을 가지며 개발자가 손쉽게 접근 및 운영할 수 있는 인프라 관리 기술
				
			(4) Backing Service:
				: 어플리케이션 실행 중 (어플리케이션이) 네트워크를 통해 사용할 수 있는 모든   attached Resource들. 

				: mySQL ,  Message queue 등
				: Message Queue >>  Asynchronous communication방식에서 마이크로 서비스 간 송수신에서 매개체 역할을 하는 미들웨어 
					: Apache Kafka >> Pub/Sub 구조에 특화된 "메세지 큐". 분산환경에 특화 설계되어있는  메시징 분산 스트리밍 플랫폼. 
						:https://m.blog.naver.com/arkdata/222632637775


				: MSA 관점에서 동기/비동기 >> 마이크로 서비스 간 커뮤니케이션 방식
					: 대체로 비동기가 좋다.  but 직접적인 응답이 필요한 등등의 일부 경우엔 동기 방식이 더 좋을 수도 있다.
					동기 Synchronous communication : 서비스끼리 서로 직접적으로 API 호출을 하고,  다른 서비스를 호출하면 자신의 작업을 중지하고 다른 서비스에서의 해당 작업이 다 끝날때까지 기다린다.
						: 서비스A의 작업 수행 괴ㅏ정에서 서비스 B에 대한 작업을 필요로 하여 서비스B를  직접 호출하고, 서비스 B에서의 해당 작업이 다 완료될 때까지 기다린다. 이 과정서 서비스 B가 서비스C에서의 작업을 필요로 해 서비스C를 또  호출하면 서비스 B도 기다리게 되고 결과적으로 서비스 A 의 작업 수행은 더 늦어진다.
						: 서비스간 결합도가 높다
						: 장애 전파에 취약하다. 중간에 한 서비스가 장애를 겪으면 그에 의존하는 작업들 모두 중단된다.

				******비동기 Asynchronous communication:  각 서비스는 독립적으로 작업을 수행하며, Message Queue 를 중간에 두고 서로를 간접적으로 호출한다. 각 서비스는 중간 중간 Message Queue 를 확인하여 자신이 처리해야하는 작업이 있나 확인하고 그를 수행한다.
						: 서비스A의 작업 수행 과정에서 서비스 B에 대한 작업을 필요로하면, 해당 이벤트를 Message Queue 에 넣어둔다. 서비스A는 이후 자신의 작업을 계속 수행하고, 서비스B는 Message Queue 에서 자신의 업무를 접수하여 작업을 수행한다
						: 서비스 간 결합도가 낮다.
						: 한 서비스가 장애를 겪어도 다른 서비스들은 그 영향을 받지 않을 확률이 높다.

					: https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-5Backing-Service-lqk3b7560w

			

				: 마이크로 서비스간의 결합도를 줄여준다
				: Banking Service 를 사용하지 않았을 떄의 문제점.
					: Message Queue 를 사용하지 않는 강한 결합 구조는 여러 서비스를 거치는 실시간 트랜잭션을 처리할 떄, 하나의 서비스가 죽어버리면 트랜잭션이 끊어지기 떄문에 해당 서비스 요청을 보존할 수 없고 큰 에러가 발생하게 됨.
					: REST 통신으로 트랜잭션 실패에 대한 처리를 구현하는 방법은 굉장히 복잡합니다.

			(5) Telemetry >> 분산된 환경에서 Monitoring,Logging,Tracer 도구를 활용하여  서비스별로 원격에서 지속적, 자동적으로 이슈에 대응할 수 있는 환경을 구성
				: 상당수의 마이크로서비스가 분산환경에서 운영되는데 이를 일일이 직접 모니터링/대응하긴 어려움
				: Tele(먼 거리) + metry(측정)
				: elastic search , aws 도 이 중 하나
				: 주요 기능
					(1) Monitoring :  MSA의 성능이나 효율성을 확인
						: AWS 에는 Amazon Cloudwatch
						: OSS 로는 Prometheus
							OSS Open Source Software : 오픈소스소프트웨어

					(2) Logging :  MSA에서 발생하는 Log들을 수집해서 보여줌
						: AWS에서는 Amazon Elastic Search 
						: OSS로는 EFK(Elastic Search - FluentD - Kibana) 
							: https://nice-engineer.tistory.com/entry/Kubernetes-Logging-%EB%A1%9C%EA%B9%85-EFK%EB%9E%80-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EB%B2%95
							: 모두 같은 회사 제품이며 Java로 만들어졌고, 클러스터 환경에서 로그를 수집, 검색 그리고 시각화를 가능하게 한다.
							Elasticsearch:  검색엔진이다. 데이터를 저장하는 저장소가 있고 그 데이터 저장소에서 검색한다.
							Fluentd 또는 Fluent Bit: 쿠버네티스 클러스터에서 로그를 수집하고, 수집한 로그 파일들을 ElasticSearch 에 전송
							Kibana:  로그를 시각화

					(3)  Tracing : MSA에서 발생한 이벤트를 순서대로 나열하여 추적할 수 있게 해줌.
						: AWS에서는 Amazon X-Ray 
						: OSS로는 Zipkin Jaeger

			(6) CI/CD Automation :  CI 와 CD를 자동화하여, 어플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법
				: CI Continuous Integeration 지속적인 통합
				: CD Continuous Delivery 지속적 전달, CD Continous Deployment 지속적인 배포

	: https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

< 실전 >


API Gateway
	:  마이크로 서비스 아키텍처에서 각 서비스의 엔드포인트 대신 API Gateway로 요청을 보내게 되며, 요청을 받은 API Gateway는 설정에 따라 각 엔드포인트로 클라이언트를 대신하여 요청하고, 응답을 받으면 다시 클라이언트에게 전달하는 프록시(proxy) 역할을 수행.
	: https://wildeveloperetrain.tistory.com/205


SCG Spring Cloud Gateway를 이용한 API Gateway 구축
	: MSA 환경에서 사용되는 API Gateway 중 하나
	: 구성
		(1) predicate : API Gateway로 "들어온" 요청이 만족해야하는 조건
			: 하나 이상의 조건을 정의할 수 있으며, 만약 Predicate 조건에 맞지 않는 경우 HTTP 404 Not Found 응답을 반환
			: 이 조건을 만족해야 라우팅시켜줌
		(2) filter :   API Gateway로 "들어온" 요청에 대해 Filter를 적용하여 선처리 및 후처리를 할 수 있게 해주는 구성요소

	: 동작 원리
		1. 클라이언트에서 들어온 요청이 Gateway Handler Mapping에 의해 predicate 조건을 만족하는 형식인지 확인
		2. Gateway Web Handler에서 요청과 관련된 필터 체인을 통해 요청이 전송
		3. 해당 필터를 통해 요청/응답에 대한 전처리 , 후처리가 이뤄짐

	: uri VS predicates
		: spring.cloud.gateway.routes.uri >> api gate way 에서 라우팅 되는, 나가는 url . 
		: spring.cloud.gateway.routes.predicates >>  api gateway 로 들어올수 있는 request url 의 형식. 

	: application.yml 설정 ex ) 
		: locallost:8000/first-service/** 요청이 gateway 로 들어오면 http://localhost:8081/ 로 요청을 전달

		server:
 		 port: 8000

		spring:
		  cloud:
 		   gateway:
 		     routes:
 		       - id: first-service
  		         uri: http://localhost:8081/
   		       	 predicates:
      		      	    - Path=/first-service/**
 		       - id: second-service
 		         uri: http://localhost:8082/
     		         predicates:
      		           - Path=/second-service/**
      		         filters:
      		           - AddRequestHeader=second-request, second-request-header
      		           - AddResponseHeader=second-response, second-response-header

	: https://wildeveloperetrain.tistory.com/207 



		: Route
			1. id : 요청"할" 서비스의 식별자
			2. uri : 요청"할" uri . 라우팅될 uri.


