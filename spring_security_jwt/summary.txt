-- 스프링 시큐리티 JWT -- 

https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC



Cookie / Session / Token 인증 방식 
	: 


HTTP 프로토콜 >>  Connectionless , Stateless 하기 떄문에 로그인 후 다시 웹페이지에 접근하면 로그인상태가 유지되지 않는다. 이러한 HTTP 프로토콜의 인증 문제( 새 요청마다 기존 연결 끊김 )를 해결하기 위해 세션과 쿠키를 사용한다.
	: Connectionless >> request 이후 response 받으면 연결이 끊어진다
	: Stateless >> 통신이 종료되면(connection 끊어지면) 어떠한 상태도 남지 않는다




Cookie 인증
	: 쿠키의 형태 >> Key-Value 형식의 문자열 덩어리
	: 단순히 클라이언트의 정보를 클라이언트 쪽에 "쿠키" 라는  작은 기록 정보 파일로 클라이언트에 심어 두는 것.
	: 절차
		1. 클라이언트가 서버에 최초 접속 요청(쿠키 없이 요청)
		2. 서버가 쿠키를 response header 에 담아서 repsonse
		3. 클라이언트는 request 보낼 떄 마다 해당 cookie 를 requset header 에 담아서 request 함
		4. 서버는 함꼐온 큐키를 통해 해당 클라이언트를 식별함. 


	: 단점
	******1. 보안에 취약. 쿠키의 값을 그대로 보내기 때문에 유출 및 조작의 위험이 존재
		2. 용량 제한
		3. 브라우저간 공유 불가능
		4 .쿠키 사이즈 커질 수록 네트워크 부하





세션인증방식 >> session Id 를 클라이언트 쪽에 쿠키로 심어두고, 클라이언트 정보는 서버쪽에 저장하는 방식
	Session Id : 세션 식별정보
		: Session Cookie 에 저장되어 있는 값으로, Session 의 id 값을 말한다.
		: 이 값으로 서버에서 로그인 된 사용자의 세션을 식별가능해진다.
		: 사용자가 동일해도 여러개의 세션을 가질 수 있다


	Session Cookie : 클라이언트의 쿠키로 저장된 세션 데이터 전체(JSESSIONID, PHPSESSIONID 등)를 의미
		: 브라우저가 종료되면 자동으로 삭제되는 휘발성 쿠키
		: 서버가 클라이언트에 세션ID를 클라이언트에게 부여하는 방법 중 하나로, 세션 식별정보를 쿠키에 담아 저장하는 것.
		: ( JSESSIONID 등의 이름의) 쿠키로 세션ID를 클라이언트에 저장해놓으면 클라이언트는 앞으로 모든 요청 헤더에 이 쿠키값을 포함시켜 보내고, 서버가 이를 식별할 수 있고, 이 값을 통해 세션을 유지할 수 있도록 한다(==JSESSIONID값을 기준으로 서버에서는 세션 메모리 영역에 상태를 유지할 값들을 저장할 수 있게 된다. (HttpSession 등) ).
	
		: 쿠키의 만료시간이 되면 클라이언트 측 쿠키는 소멸되기 때문에( 더이상 해당 세션ID를 가지지 않아서) 동일한 클라이언트가 보낸 요청이라고 해도 서버는 새로운 클라이언트로 인식하게 된다. 하지만 이전에 서버측에 생성된 세션 정보는 유지될 수 있고, 아직 "Invalidate"가 되지 않는다.
			: 세션 타임아웃
				; HTTP는 connectionless하고 stateless이기 때문에 클라이언트측의 세션 쿠키 소멸을 서버가 직접적으로 알 수 없다. 그렇기 때문에  클라이언트측의 세션 쿠키가 소멸되었다고해서 서버 내의 세션의 삭제도 즉시 이루어지는게 아니라 일정 시간 동안 유지된다.. 서버는 일정 시간이 지나면서 세션 데이터를 만료시키고 삭제하게 되어있는데, 이 시간을 '세션 타임아웃'이라고 부름.  
				: 세션 타임아웃이 되면 서버는 해당 세션 데이터를 삭제하고, 인지할 수 없는 세션 Id 를 포함하는 요청에 대해서는 새로운 세션을 생성함. 
		 :https://www.inflearn.com/questions/853519/%EC%84%B8%EC%85%98-%EC%82%AD%EC%A0%9C-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8



	: 동작 방식
		1. 유효한 JsessionId없이 reqeust 할 시(브라우저에 최초 접근 시) 톰캣은 session ID값 발급하고이를 Response 헤더에  포함하여 response
		2. 이후 해당  session ID값을 헤더에 포함해 reqeust 할 시(브라우저 재요청시) 서버는 새로운  session ID값을 발급하진 않고 , 클라이언트로부터 전달받은  session ID값을 기준으로 서버의 세션 메모리 영역에 상태를 유지할 값들을 저장/접근하여 사용한다.
 

	세션 단점
		1. 세션 쿠키 자체에는 세션 id 값만 있지, 유의미한 정보를 가지지 않기 떄문에 Http 요청 중 노출되어도 큰 문제는 없으나, 그 쿠키 자체를 훔쳐 ( 세션 하이재킹 ) 서버에 해당 쿠키로 접근하면 중요한 정보를 뺴낼 수 있다는 문제점이 있다.

		2. 서버에 세션을 저장하기 떄문에 사용자수가 많아지면 서버의 부담이 커진다.



	세션 유효 범위
		 : https://dololak.tistory.com/543
		: 쿠키는 기본적으론 쿠키가 생성된 서버로만 전송됨. 그러니까 google 에서 생성된 쿠키는 naver 로 request 할 떄 전송되지 않음. 
		: 대규모 웹 서비스는 하나의 웹서버가 아닌 여러 웹서버가 하나의 시스템을 이루면서 운영되는 경우가 있는데 다른 서버에도 해당 쿠키가 전송되게 하려면 다른 방법이 필요 << 추후 기술
		: 동일한 Full 도메인 ( 서브도메인이 다를 경우 쿠키가 유지되지 않기 때문)
  

 

 

세션과 토큰 인증 방식 Stateless, stateful
	: Stateful >>  세션 기반 인증 방식. 서버에서 클라이언트의 이전 상태를 기록.
	: Stateless >> 서버에서 Http와 같은 cilent 의 이전 상태를 기록하지 않는 접속
		: caching, load balancing, scale out 등의 장점이 있지만 매 요청마다 클라이언트의 상태정보를 전달받아야되기 떄문에 네트워크 자원을 소모하며, 서버는 정보 처리를 위한 작업이 필요
		: REST api 에서 각각의 요청은 독립적인 stateless 방식

	: https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC
	: https://russwest.tistory.com/40\


토큰 인증 방식
	: 서버의 토큰을 이용하여 인증을 수행하는 방법
	: 세션 기반 인증방식인 stateful 과는 다르게 서버에 클라이언트의 상태 정보를 저장하지 않아서 서버의 부담을 줄일 수 있다
	1. 사용자가 토큰없이(최초로그인) request 
	2. 서버가 사용자 검증 통해 유효성 확인 후 통과하면 토큰을 response 와 함꼐 반환
	3. 클라이언트는 토큰을 저장하고, 서버 요청 시  request 할 떄마다 토큰을 request header 에 담아서 보냄
	4. 서버는 토큰 검증 후 요청에 respnose.

토큰 방식 장점
	1. 서버 부담 감소 : 일일이 사용자의 정보를 저장할 필요 없음
	2. csrf 방지 : 



Session 인증

	: 세션 객체의 형태 >> key 에 해당하는 sessionID 와 이에 대응하는 Value 로 구성되어있다,
		: value >> creationTIme ( 세션 생성 시간 ), lastAccessedTime , ... 등이 map 형태로 저장된다


	: 절차
		1. 유저가 웹사이트에서 로그인하면 세션이 서버 상에 저장된다. 이때, 세션을 식별하기 위한 Session Id를 기준으로 정보를 저장한다.
		2. 서버에서 브라우저에 쿠키에 Session Id를 저장한다.
쿠키에 정보가 담겨있기 때문에 브라우저는 해당 사이트에 대한 모든 Request에 Session Id를 쿠키에 담아 전송한다.
서버는 클라이언트가 보낸 Session Id 와 서버 메모리로 관리하고 있는 Session Id를 비교하여 인증을 수행한다.


	: 단점
		1. 요청이 외부에 노출되더라도 세션 ID 자체는 유의미한 개인정보를 담고 있지 않는다.그러나 해커가 세션 ID 자체를 탈취하여 클라이언트인척 위장할 수 있다는 한계가 존재한다. (이는 서버에서 IP특정을 통해 해결 할 수 있긴 하다)
		2. 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 심해진다.



Token 인증
	: 클라이언트가 서버에 접속을 하면 서버에서 해당 클라이언트에게 인증되었다는 의미로 '토큰'을 부여한다. 이 토큰은 유일하며 토큰을 발급받은 클라이언트는 또 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다. 그러면 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증 과정을 처리하게 된다.
	: 세션방식과 다르게 토큰은 클라이언트에 저장되기 떄문에 서버의 부담을 덜 수 있따. 
	: 웹에는 쿠키와 세션이 있지만 앱에서는 없기 때문에 모두 가능한 토큰을 가장 많이 사용한다
	: 상태를 유지하지 않으므로 Stateless 한 특징을 가지고 있다.
	: 방식
		1. 클라이언트가 로그인 성공
		2. 서버측에서 유일한 토큰 발급하여 response
		3. 클라이언트는 받은 토큰을 쿠키나 스토리지에 저장해두고 서버에 요청을 할 떄마다 해당 토큰을 Http request header 에 포함하여 전달
		4. 서버는 전달받은 토큰을 검증하고 response. 
			: db 를 조회하지 않고도 누가 요청했는지 알 수 있다.

	: 단점 
		1. 토큰 자체의 데이터가 커서 네트워크 부하가 심해질 수 있다.
		2.내부 정보를 단순 BASE64 방식으로 인코딩하기 때문에 외부에서 쉽게 디코딩 할 수 있어서 유저의 중요한 정보는 담을 수 없다.
		3. 토큰을 탈취당하면 대처하기 어렵다. (따라서 사용 기간 제한을 설정하는 식으로 극복한다)



서버(세션) 기반 인증 시스템 >> stateful
토큰 기반 인증 시스템 >> stateless


JWT (JSON Web Token) : 인증에 필요한 정보들을 암호화시킨 JSON 토큰
	:: JSON 데이터를 Base64 URL-safe Encode 를 통해 인코딩하여 직렬화한 것
	: 내부에는 위변조방지를 위한 개인키를 통한 전자서명도 있다.

	: 구조 >> . 을 구분자로 나눠지는 3가지 문자열의 조합




--------------------------------------------------------------------------------------------------------------

@Bean 에 파라미터가 있을 경우 자동으로 DI 된다. @Bean  에 @Autowired 있다고 보면 된다.

https://kimcoder.tistory.com/459

https://www.logicbig.com/tutorials/spring-framework/spring-core/javaconfig-methods-inter-dependency.html


https://www.inflearn.com/questions/796060/bean-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EC%9E%88%EC%9D%84-%EA%B2%BD%EC%9A%B0-%EB%B9%88-%EC%83%9D%EC%84%B1-%EB%93%B1%EB%A1%9D-%EC%88%9C%EC%84%9C




--------------------------------------------------------------------------------------------------------------

@Value >> application.yml , application.properties 내의 값을 클래스의 원하는 위치에 DI 시키는데 사용한다.	
	: @Autowired 랑 비슷한 개념. ( 다만 빈을 주입하는게 아니라 application.yml , application.properties내의 값을 주입하는 것)

	: @Value("${ 값가져오고싶은변수}" ) 의 꼴을 아래의 위치에 명시
		case 1. 필드 위에
		case 2. 파라미터 앞에

	: 주의 >>  static 필드에는 주입이 되지 않는다.

	: ex ) application.yml 에
		my:
  			name: duck
  			age: 23
		이런식으로 있다면

	어쩌구.java 에서 
	@Value("${my.name}") String name 과 같이 하면 name 에 duck 이 들어간다.
	초기값 설정 시 유용하게 쓸 수 있는데, 되도록이면 필드 주입 말고 생성자 주입을 하라는 것 같다.
	ex ) 
@Service
public class Service {

	@Value("${value.test}")
	private String test;
   }

보다는 

@Service
public class Service {
	private String test;
	public Service(@Value("${value.test}") String test) { 
		this.test = test;
		  }
}

처럼 해라
		
	: https://velog.io/@jduckling_1024/Value%EB%A1%9C-application.yml%EC%9D%98-%EA%B0%92-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0

--------------------------------------------------------------------------------------------------------------


: principal >> 유저. 사용자를 통칭하는 말.
	: https://devidea.tistory.com/16
	

principal 인터페이스
	: https://codevang.tistory.com/273
	: 컨트롤러의 메소드에서 Model 과 같이 파라미터로 별도의 빈 등록 없이 DI 받을 수 있는 타입 중 하나
	: 구현체의 최상위 인터페이스이기 때문에 이 타입으로 받으면 사용할만한 메소드가 getName() 정도밖에 없다

	▼ Athentication 인터페이스
		: UsernamePasswordAuthenticationToken 구현체 및 세션 정보를 보관하는 객체에서 필요한 정보를 뽑아내는 메소드를 보유. 
			Object getPrincipal() : 구현 객체 생성 당시 할당한 principal 객체 반환
				: 반환형이 objec t 이기 떄문에 UserDetails user = (UserDetails) authentication.getPrincipal(); 과 같이 사용 가능 
			Object getCredentials() : 구현 객체 생성 당시 힐당한 credentials 객체 반환 
			Collection<? extends GrantedAuthority> getAuthorities() :  구현 객체 생성 당시 힐당한 권한 리스트 객체 반환 
			Object getDetails() : 세션정보를 가진 WebAuthenticationDetails 객체 반환
		:  실제로 인증 정보를 사용하기 위해 사용되는 타입

		▶ UsernamePasswordAuthenticationToken  구현 클래스 
			: 인증이 완료된 후 최종적으로 스프링 Security에게 전달해주는 구현체
			: 생성자 >> public UsernamePasswordAuthenticationToken (Object principal, Object credentials,  Collection<? extends GrantedAuthority> authorities)
				: principal 자리에 userdetails 객체를 넣어주는게 좋다
				: 딱히 필요 없는 건 null 값 넣어주면 된다
		▶ AbstractAtuthenticationToken 추상클래스 
		▶ RememberMeAuthenticationToken  구현클래스



--------------------------------------------------------------------------------------------------------------

이거 왜 꼭 우리가 arg 로 넣어줘야되는지 모르겠는데 나중에 함 보기

@Bean
public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

https://velog.io/@waveofmymind/blog-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%B2%98%EB%A6%AC-Spring-Security



--------------------------------------------------------------------------------------------------------------

JWT 인증 방식 시큐리티 동작 원리
	: 회원가입 >>  ( 클라이언트에게 폼데이터로 요청받는게 아니라 JSON 으로 요청받는건 다르지만) 내부적인 로직은 세션 방식과 JWT 방식의 차이가 없다.

	: 로그인 (인증) >>  로그인 요청을 받은 후 세션 방식은 서버 세션이 유저 정보를 저장하지만 JWT 방식은 토큰을 생성하여 응답한다.
		: 세션 방식과는 다르게 직접 필터 로직을 작성해야된다
		: UserDetails 구해서 검증하는 것 까지는 세션방식과 같지만, 로그인이 성공했을 떄 그 정보를 저장하는 방식이 다르다.  세션에다가 유저 정보를 저장하지 않고 JWT 토큰을 만들어 response .

	: 경로 접근 (인가) >> JWT Filter를 통해 요청의 헤더에서 JWT를 찾아 검증을하고 일시적 요청에 대한 Session을 생성한다. (생성된 세션은 요청이 끝나면 소멸됨)
		: JWT Filter 우리가 강제로. 필수적으로 커스텀해서 만들어야됨
		: JWT Filter 에서 해당 토큰이 알맞게 존재하고 일치하면 일시적인 세션을 만들고, 특정한 경로로 요청할 경우 그 세션에 정보가 저장되있기 떄문에 그 특정 경로에 접근 가능하게 된다.
		: stateless 로 관리되기 떄문에 단 하나의 세션에 대해서만 일시적으로 만들고 그 요청이 끝나버리면 세션이 다시 사라진다. 그러니까 새로운 요청을 받으면 동일한 아이디라도 그 요청에 대한 세션을 또 따로 만든다.



--------------------------------------------------------------------------------------------------------------

의존성 추가

- 필수 의존성
    - Lombok
    - Spring Web
    - Spring Security
    - Spring Data JPA
    - MySQL Driver

일단 데이터베이스 의존성 임시로 주석 처리>> 스프링 부트에서 데이터베이스 의존성을 추가한 뒤 연결을 진행하지 않을 경우 런타임 에러 발생
//	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
//	runtimeOnly 'com.mysql:mysql-connector-j'


### JWT 필수 의존성
	: 이건 직접 수동으로 추가해야된다.
	: 대부분은 JWT 0.11.5 버전을 통해 구현하지만 최신 버전은 0.12.3
		: 버전별로 구현 방법이 매우 다르다.

0.12.3 추가 방법

dependencies {
	. . .
    implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
    implementation 'io.jsonwebtoken:jjwt-impl:0.12.3'
    implementation 'io.jsonwebtoken:jjwt-jackson:0.12.3'
	. . .
}


0.11.5 추가 방법

dependencies {
	. . .

    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    implementation 'io.jsonwebtoken:jjwt-impl:0.11.5'
    implementation 'io.jsonwebtoken:jjwt-jackson:0.11.5'
	. . .

}






--------------------------------------------------------------------------------------------------------------
SecurityConfig 클래스  >> 스프링 시큐리티의 인가 및 설정을 담당하는 클래스
	: 버전별로 구현 방법이 다르다. 실습은 6.2.1 기준 진행된다
	:  
		1. bCryptPasswordEncoder 메서드 >> pw 암호화 위해 빈 등록
		2. filterChain 메서드 >> 세션을 stateless 하게 설정 / stateless 하므로 csrf 설정을 해제 / jwt 로 로그인 할 것이니 formlogin 과 httpbasic 기능 모두 해제 / 경로별 인가 작업


@EnableWebSecurity
@Configuration
public class SecurityConfig {

    // 암호화 위해 BCryptPaasswordEncoder 등록
    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http)throws Exception {
        // JWT를 통한 인증/인가를 위해서 세션을 STATELESS 상태로 설정
        http.sessionManagement(session->session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS));

        //csrf 해제
        //세션 방식의 Spring security 의 경우 세션 방식이 고정되있어 csrf 공격에 필수적으로 대비해줘야되지만 jwt 는 stateless 하게 관리하기 떄문에 별다른 대비가 필요없다
        http.csrf(auth->auth.disable());


// jwt 로 로그인 할거라 FormLogin 방식, HttpBasic 모두 해제
        //From 로그인 방식 disable
        http.formLogin((auth) -> auth.disable());

        //http basic 인증방식 disable
        http.httpBasic((auth) -> auth.disable());


        // 경로별 인가 작업
        http.authorizeHttpRequests(auth->auth
                .requestMatchers("/login","/","/join").permitAll()
                .requestMatchers("/admin").hasRole("ADMIN")
                .anyRequest().authenticated());



        return http.build(); // 빌더 타입으로 리턴
    }
}



--------------------------------------------------------------------------------------------------------------

POSTMAN >> API 클라이언트. API 기반 요청 보낼 수 있는 소프트웨어
	: post 요청이나 jwt 토큰 같은거 포함하는 요청은 일반 브라우저로 할 수 없어 깔아야됨.

--------------------------------------------------------------------------------------------------------------

DB 연결 및 Entity 와 Repository 선언

데이터베이스 의존성 주석 해제 > 이제 연결 설정할 거니까

 application.properteis 설정 > 

#db 연결
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://아이피:3306/데이터베이스?useSSL=false&useUnicode=true&serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true
spring.datasource.username=아이디
spring.datasource.password=비밀번호

#ddl > 이미 db에 해당 테이블이 존재한다묜 none 으로, 없다면 update 나 create .
spring.jpa.hibernate.ddl-auto=none
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl


회원 테이블 Entity 작성 : UserEntity >
@Entity
@Setter
@Getter
public class UserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    private String username;
    private String password;

    private String role;
}


회원 테이블 Repository 작성 : UserRepository > 논리적pk 존재여부 확인 위해 별도의 메서드 선언

public interface UserRepository extends JpaRepository<UserEntity, Integer> {

    public abstract   Boolean existsByUsername(String username);
    public abstract UserEntity findByUsername(String username);


}



--------------------------------------------------------------------------------------------------------------

회원가입 로직 >>

RestController 와 Service 단 선언


@RestController
public class JoinController {
    

    @Autowired
    private JoinService joinService;

    @PostMapping("/join")
    public ResponseEntity<JoinDTO> joinP(JoinDTO dto){
        JoinDTO saved = joinService.JoinP(dto);
        return ResponseEntity.status(HttpStatus.OK).body(saved);
    }
}



서비스 단에서 password 암호화 한 후에 저장해야함 까먹지 x.

@Service
public class JoinService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private BCryptPasswordEncoder bCryptPasswordEncoder;

    public JoinDTO JoinP(JoinDTO dto){
        boolean exist = userRepository.existsByUsername(dto.getUsername());

        if(exist) return null;

        UserEntity entity = new UserEntity();
        entity.setPassword(bCryptPasswordEncoder.encode(dto.getPassword())); // 암호화를 한 후 넣어야됨
        entity.setUsername(dto.getUsername());
        entity.setRole("ROLE_ADMIN");
        userRepository.save(entity);
        return JoinDTO.toDTO(entity);

    }
}


--------------------------------------------------------------------------------------------------------------

로그인 필터 구현
	
세션 방식으로 Spring Security 를 구현 할 떄는 UsernamePasswordAutneticationFIlter 와 AthenthicationManager 를 별도로 구현하지 않아도 됬음. 근데 JWT 방식으로 할 떈 "formLogin 방식을 disable 시켰기 떄문에" 반드시 직접 구현 해줘야됨

UsernamePasswordAutneticationFIlter >> 사용자로부터 입력받은 데이터에서 username 과 password 정보를 꺼내서(걸러서) AthenthicationManager에게 넘겨줌

AthenthicationManager >> UsernamePasswordAutneticationFIlter 에게 받은 username 과 password 정보로 UserDetailsService 가 UserDetails를 사용해서 검증을 진행 및 결과 반환 

SuccessfulAthentication >>AthenthicationManager 에서 검증이 성공되면 실행된다. JWT 를 생성해서 사용자에게 응답해준다.


UnSuccessfulAthentication >> AthenthicationManager 에서 검증이 실패하면 실행된다.  JWT 를 따로 생성하진 않고 에러 코드만 보낸다.





스프링 시큐리티 동작 원리
	: 기본적인 스프링 부트의 동작 원리>> Servlet Container 에는 여러개의 필터가 있는데 사용자로부터 request 가 들어오면 ServletContainer 내부의 여러 필터를 거쳐서 SpringBoot , 즉 컨트롤러에 전달된다.
	
	: 스프링 시큐리티 동작원리 >> 사용자로부터 request 가 왔을 떄 스프링시큐리티는 Servlet Container 내부의 필터부애 도착한 request 를 가로채서 검증(인증/인가) 하고, 그  결과에 따라 컨트롤러에 전달해주고 안해준다.

		1. 스프링 시큐리티를 의존성으로 추가하면,  서블릿 필터 체인(Servlet Container 에 존재하는 필터 체인) 중간에 DelegatingFilter가 등록된다.
			: 이떄 DelegatingFilter 는 서블릿 필터 체인에 속한 필터인 것이다.
			: Delegate : 대표자. 위임자. >> 그러니까 DelegatingFilter는 역할을 ( 시큐리티 필터로 ) 위임하는 필터란 뜻

		2. DelegatingFilter 가 자신이 받은 요청을 시큐리티 필터 체인( Spring Security 가 관리하는 별도의 필터)의 필터에 전달한다.

		3. 시큐리티 필터체인 이 검증 결과에 따라 리다이렉션 거부 등의 동작을 수행한다


핵심 시큐리티 필터
	: UsernamePasswordAuthenticationFilter
		: request 로 보내진 username과 password로 회원 검증을 진행을 시행하는 부분,
		: formLogin 방식을 사용할 떄 해당 필터는 기본적으로 활성화되어 별다른 구현이 필요 없지만, formLogin 방식을 해제한 경우 직접 . 필수적으로 . 구현해야된다. 
			: https://docs.spring.io/spring-security/reference/servlet/architecture.html 에서 확인 가능( formLogin 방식 쓸 떄 UsernamePasswordAuthenticationFilter 가 add 되는 것.)



******커스텀 필터 : 직접 내용을 구현한 필터는 SecurityConfig에 등록해야 사용 가능하다





커스텀 UsernamePasswordAuthenticationFilter 구현
	: jwt 라는 패키지를 별도로 만들고 거기에 저장
	: 다 만들면 SecurityConfig.java 에 필터로 등록



public class LoginFilter extends UsernamePasswordAuthenticationFilter {
    //  attemptAuthentication 에서 authenticationManager 에게 토큰 전달위해 DI
    @Autowired
    private AuthenticationManager authenticationManager;


    //  필수로 오버라이드 필요
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {

	// 추출
        String username = obtainUsername(request);
        String password = obtainPassword(request);

        // DTO역할을 하는UsernamePasswordAuthenticationToken이라는 바구니에 넣음
       	 //UsernamePasswordAuthenticationToken(username값,password값,role값);
        UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(username,password,null); // 일단 당장은 role 이 없으니 null 값넣었다

        // 생성한 토큰을 AthenthicationManager 에게 넘겨줌 --> authenticationManager 가 알아서 검증해줌
        return authenticationManager.authenticate(authToken);
    }



    // authenticationManager 가 성공적으로 검증을 마쳤을 때 실행되는 메서드 . 여기서 JWT 를 발급한다!!!
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {

       구 현

    }


    //  authenticationManager 가 검증을 실패했을때 실행되는 메서드
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
       
		구 현

    }



}







attemptAuthentication 는 필수로 오버라이딩한다. 이 메서드가 요청을 가로채서 username 과 password 추출하고, 이를 기반으로 토큰을 만들고, AthenthicationManager에게 해당 토큰을 전달하게 된다.

obtainUsername , obtainPassword 메서드를 통해 request 객체에서 각각 username 과 password 를 추출한다. 

AthenthicationManager에게 그냥 띡 username 과 password 를 전달해주면 안되고,  해당 정보를 DTO역할을 하는UsernamePasswordAuthenticationToken이라는 바구니에 담아서 전달해줘야 하기 떄문ㅇㅔ UsernamePasswordAuthenticationToken 객체 그러니까 토큰을 생성한다. 생성자의 arg 로는 username값, password값, role값이 들어간다.


 return authenticationManager.authenticate(authToken) 
	:  Authentication authenticate(Authentication authentication)  메서드>> 토큰의 유효성 검사하는 메서드
		: authenticationManager 의 메서드로 , arg로 들어온 토큰을 기반으로 userDetailsService 를 통해 userDetails 객체를 얻고, 이를 필드로 가지는 Authentication 객체를 반환하고, SecurityContextHolder 에 저장되기 때문에 꺼내쓸 수 있다.

		: 유효성 검증에 성공하면 인증 성공 이벤트가 발생하고, 이벤트 처리 핸들러인 AuthenticationSuccessHandler 에 의 해 successfulAuthentication 이 호출된다.
	
AthenthicationManager에게 생성한 토큰을 전달해주기 위해서 AthenthicationManager 의 authenticate 메서드가 필요함으로 AuthenticationManager 를 @Autowired 받게 하고 그 객체를 대상으로 authenticate 메서드를 사용하며 앞서 생성한 토큰을 arg 로 한다
	: AthenthicationManager 은 별도로 @Bean 등록이 되지 않은 상태이므로 잊지말고 SpringConfig 에서 @Bean 등록해준다.

@EnableWebSecurity
@Configuration
public class SecurityConfig {

	. . .

    //AuthenticationManager Bean 등록
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception {

        return configuration.getAuthenticationManager();
    }
. .. 

}



AthenthicationManager가 인증을 성공적으로 마쳤을 경우 수행될 successfulAuthentication 와 unsuccessfulAuthentication 또한 오버라이드한다
	: 참고로 이 둘은 UsernamePasswordAuthenticationFilter의 직속 메서드는 아니고 그의 인터페이스인 AbstractAuthenticationProcessingFilter의 추상 메서드이다.

	: successfulAuthentication 에서 jwt 를 발급하게 된다.




만든 필터 등록 >> SecurityConfig 에서 addFilterXX ( 내가만든필터객체 , 기존필터명.class )  를 활용한다.
            addFilterAt(  내가만든필터객체 , 기존필터명.class) >> 딱 그자리에 필터를 등록. 즉, 특정원본필터를 대체
		: 그러니까 부모를 자식으로 대체하려면 이걸활용해야된다.

            addFilterBefore( 내가만든필터객체 , 기존필터명.class ) >> 특정필터 앞에 해당 필터 추가 
            addFilterAfter(  내가만든필터객체 , 기존필터명.class) >> 특정필터 뒤에 해당 필터 추가


@EnableWebSecurity
@Configuration
public class SecurityConfig {


    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http)throws Exception {

	. . .
        
      
        http.addFilterAt(new LoginFilter(), UsernamePasswordAuthenticationFilter.class);


	. . . 

        return http.build(); // 빌더 타입으로 리턴
    }
}








--------------------------------------------------------------------------------------------------------------

AuthenticationManager 이후 부분( userdetails 	~  db ) 은  세션 방식과 동일

CustomUserDetailsService 는 인증하는 부분이지, 새 user 를 등록하는 부분이 아니다.
	: 
	: 새 user 를 등록하는건 별도로 JoinController 같은거 만들어서 한다.



@EqualsAndHashCode
@ToString
@AllArgsConstructor
@NoArgsConstructor
public class CustomUserDetails implements UserDetails {

    private UserEntity userEntity;


    // roll 값들을 반환한다.
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {

        Collection<GrantedAuthority> collections = new ArrayList<>();

        // 해당 entity 의 roll 값을 뽑아서 collection 에 add 한다
        collections.add(new GrantedAuthority() {
            @Override
            public String getAuthority() {
                return userEntity.getRole();
            }
        });

        return List.of();
    }

    @Override
    public String getPassword() {
        return userEntity.getPassword();
    }

    @Override
    public String getUsername() {
        return userEntity.getUsername();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
}




@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    // 로그인 검증 용 . db의 정보와 일치하는가
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        UserEntity entity = userRepository.findByUsername(username);

        if(entity!=null)return new CustomUserDetails(entity);

        return null;
    }
}

--------------------------------------------------------------------------------------------------------------

JWT 발급 및 검증 
- 로그인시 → 성공 → JWT 발급
- 접근시 → JWT 검증
	: 우리 서버에서 생성된건지. 유효기간 지났는지. .. 등 검증





 JWT 암호화 방식
- 암호화 종류
    - 양방향 : 다시 복호화 가능한 암호화
        - 대칭키 : 동일한 키로 암호화와 복호화 진행 << 이 프로젝트에서 구현
		: 해당 키는 절대 외부에 노출되면 안된다.
		: 키의 길이에 따라 암호화의 종류가 다르다 >>128bit , 192bit, 256bit (HS256)

        - 비대칭키 : 각각 다른키로 암호화와 복호화 진행 ( public key 와 secrete key )

    - 단방향 : 다시 복호화 불가한 암호화


JWT 특징 : header 와 payload 는 간단ㅎl base64 방식으로 인코딩만해두기 때문에 외부에서 언제든지 내부 데이터를 디코딩하여 확인 가능하다. 따라서 외부에서 열람해도 되는 정보만 담아야된다. (username 과 role 값 정도는 담아도 되지만 password 그런 것 까지 담으면 ㅈ된다)
	: 비밀번호 같은 것도 담지 못하는데 왜쓰냐 ? ? >> 토큰 자체의 발급처를 확인하기 위해 사용
		 : 토큰 안에 담긴 내용을 해석하는건 쉽지만 원본을 위조하기는엄청힘들다. ( 화폐가 얼만지는 눈으로 얼마든지 확인할 수 있지만 지폐는 위조하기 힘든 그런st)




JWT >> JSON 타입의 웹토큰으로 문자열 형태를 띠고 있다. 2개의 . 을 구분자로하여 해더/페이로드/시그니쳐 부분으로 구분하여 내부의 데이터를 전달한다.
	: https://velog.io/@jungmin_/%ED%86%A0%ED%81%B0%EA%B8%B0%EB%B0%98-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%9D%B8%EC%A6%9D-JWT

	: ex) header , payload , signature 를 조합> ewogICJhbGciOiAiSFMyNTYiLAogICJ0eXAiOiAiSldUIgp9.ewogICJpc3MiOiAic2VydmVyIgogICJhdWQiOiAidXNlcjEiCiAgInN1YiI6ICJzdWJqZWN0IgogICJpYXQiOiAxNzAxMDA4MTQxIAogICJleHAiOiAxNzAxMDA4NDQxCiAgInVzZXJJZCI6IDEKICAiZW1haWwiOiAidXNlcjFAZXhhbXBsZS5jb20iCn0._YIWNJdMwXo1GwUuQ-k3i9f_gdHnPkr2CVQ2EW9qyO4

1. Header >> 서명에 사용된 알고리즘 정보와 토큰의 종류를 명시. base64 인코딩 된다.
	ex)  
	원본 > HMAC-SHA256 암호화 알고리즘을 사용한 JWT토큰이라는 정보를 담고 있다.
	{
  	"alg": "HS256",
  	"typ": "JWT"
	}

	헤더를 base64 인코딩 > ewogICJhbGciOiAiSFMyNTYiLAogICJ0eXAiOiAiSldUIgp9


2. Payload >> 주요 정보를 담고있는 부분. base64 인코딩된다.
	 : body 랑 비슷		
	: 주의 >  토큰을 가진다면 누구나 정보를 확인 할 수 있으므로 민감한 정보는 절대 포함시키면 안된다.
	: 페이로드는 하나의 json 에 모두 작성된다.
	: 클레임 >페이로드 부분의 key 와  value 의 쌍. 3가지의 클레임으로 구성될 수 있으며 클레임들은 필수적으로 사용하지 않아도 된다.
		ex ) 
		원본 페이로드 >
		{
 		 "iss": "server"
  		"aud": "user1"
  		"sub": "subject"
 		 "iat": 1701008141 
  		"exp": 1701008441
  		"userId": 1
 		 "email": "user1@example.com"
		}

		페이로드를 base64 로 인코딩 > ewogICJpc3MiOiAic2VydmVyIgogICJhdWQiOiAidXNlcjEiCiAgInN1YiI6ICJzdWJqZWN0IgogICJpYXQiOiAxNzAxMDA4MTQxIAogICJleHAiOiAxNzAxMDA4NDQxCiAgInVzZXJJZCI6IDEKICAiZW1haWwiOiAidXNlcjFAZXhhbXBsZS5jb20iCn0

		(1) 등록된 클레인 registered claim : JSON Web Token Claims라는 레지스트리에 등록된 클레임
			iss(Issuer) Claim : 토큰을 발급한 대상을 말한다.
			sub(Subject) Claim : 토큰의 제목을 말한다.
			aud(Audience) Claim : 토큰을 받는 대상자를 말한다.
			exp(Expiration Time) Claim : 토큰의 유효기간을 말한다.
			nbf(Not Before) Claim : 토큰이 활성화되는 시간을 말한다.
			iat(Issued At) Claim : 토큰이 발급된 시간을 말한다.
			jti(JWT ID) Claim : 토큰의 ID를 말한다.

		(2) 공개 클레임 Public Claim : 토큰을 사용하는 사람들이 정의하는 클레임으로, 충돌 방지를 위해서 다른 이름과 중복되지 않는 이름으로 지어야됨.

		(3) ㅂ;공개 클레임 private claim : 토큰 공급자와 토큰 사용자 간에 협의된 클레임으로 다른 클레임과 충돌되지 않게 사용하면 된다.



3. Signature : 암호화알고리즘을 사용하여 헤더와 페이로드를 각각 base64 방식으로 인코딩한 값을 또 시크릿키로 암호화 한다( (BASE64(Header))+(BASE64(Payload)) + 암호화키 ). 이 암호화된 값을 통해 이 토큰의 무결성을 검증할 수 있다.
    - 암호화알고리즘
	: 발행한 서버 혹은 시크릿 키를 가진 서버끼리만 검증을 진행할 수 있도록 BASE64 방식으로 인코딩해서 암호화 한다.
	: 만약에 payload 부분을 해킹해서 변경했다하면( ex : user 권한을 admin 권한으로 변경), 변경한내용을 base64 적용하고 시크릿키 적용했을 때 기존 signature 부분과 달라지기 떄문에 해당 토큰은 반려되게 된다

	ex)  
	헤더와 페이로드를 마침표로 구분한 ewogICJhbGciOiAiSFMyNTYiLAogICJ0eXAiOiAiSldUIgp9.ewogICJpc3MiOiAic2VydmVyIgogICJhdWQiOiAidXNlcjEiCiAgInN1YiI6ICJzdWJqZWN0IgogICJpYXQiOiAxNzAxMDA4MTQxIAogICJleHAiOiAxNzAxMDA4NDQxCiAgInVzZXJJZCI6IDEKICAiZW1haWwiOiAidXNlcjFAZXhhbXBsZS5jb20iCn0
	를 이용하여 암호화 결과 > _YIWNJdMwXo1GwUuQ-k3i9f_gdHnPkr2CVQ2EW9qyO4

 

--------------------------------------------------------------------------------------------------------------

JWT 를 암호화, 복호화할 키를 만들기
	: application.properties 에 선언
		: 클래스 내부에도 만들 수 있지만 외부에도 노출될 수 있고, 여러개의 서버를 띠울때 암호를 수정하기가 어려워지기 떄문 
		: spring.jwt.secret =vmfhaltmskdlstkfkdgodyroqkfwkdbalroqkfwkdbalaaaaaaaaaaaaaaaabbbbb
			: spring.jwt.secret  으로 꼭 이름을 설정하지 않아도 된다. 이름은 자윤데, 이미 존재하는 키워드랑 겹치면 안된다.
			: 키 값은 vmfhaltmskdlstkfkdgodyroqkfwkdbalroqkfwkdbalaaaaaaaaaaaaaaaabbbbb 아니라 딴 것도 가능하고 , 최대한 길게 설정한다.  (: HS256 > 256 자 up 굿. )


--------------------------------------------------------------------------------------------------------------

발급과 검증을 담당할 클래스( JWTUtil 클래스. 이름은 자유 .) 직접 구현하기
해당 클래스을 @Component 로 등록해서 여러군데서 사용한다

Util 클래스 > 특정 파라미터에 대한 작업을 수행하는 메서드들을 가지는 클래스
	


JWTUtil >>  토큰 생성, 검증, 정의를 하는 클래스
	: 이름은 상관없다
	: jwt 패키지에 구현
	: @Component 로 spring 에 의해 관리되게 함


 0.12.3 구현 실습


https://green-bin.tistory.com/50
Java - AES-128 양방향 암호화

application.properties 에 선언한 시크릿키값을 JWTUtil 의 생성자 부분에서 @Value("${시크릿키명}")을 이용해 주입 시킨다.
	: @Value 는 lombok 불러오는게 아니라 org.springframework.beans.factory.annotation.Value 임을 주의

주입받은 문자열 타입의 키값을 기반으로 암호화된 객체타입의 키를 생성한다.
	: new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), Jwts.SIG.HS256.key().build().getAlgorithm());

		: SecretKeySpec( 바이트배열타입의키 , 문자열타입의알고리즘 )  > secrete key 를 만드는데 사용되는 라이브러리
			: secret.getBytes(StandardCharsets.UTF_8) >>  secret 은 내부적으로 내가 secretkey 값을 담아둔 문자열필드. 이를 UTF_8인코딩 방식의 getBytes( ) 를 이용해 바이트타입배열로 변환
			:  Jwts.SIG.HS256.key().build().getAlgorithm() >>  HMAC-SHA256 방식 알고리즘을 문자열화




검증 메서드를 구현한다
	        return Jwts.parser().verifyWith( secretKey ).build().parseSignedClaims( token ).getPayload().get("username",String.class);

  	: 토큰을 전달 받아 내부의 Jwts 의 parser 를 이용해 분석한다
	: JWT 토큰은 문자열타입 이므로 문자열 타입으로 토큰받는 파라미터 선언
  	 : verifyWith( 객체키 ) >> 특정객체 키를 이용하여 parse 를 (디코딩) 하게 설정한다
		: 그러니까 토큰 생성 부분에서 .signWith(객체키) 했었던  arg 로 들어간 객체와 같은 객체를 arg 로 하면 된다.
    	: parseSignedClaims( 클라이언트가준토큰 ) >> 앞서 설정한 기준으로 클라이언트가 준 토큰을 parse 진행한다.
    	: getPayload( ).get("키명", 키의값타입.class)  >> custom claim 을 가져온다.
     	: getExpiration().before(new Date() ) >>  Standard Claim 중 하나인 Expiration 클레임을 가져오고 오늘을 기준으로 만료되었는지 확인한다. 이외의 Standard Claim  은 이처럼 getter 계열 메서드를 활용해 간푠히 가져올 수 있다.
        :  new Date( ) == 현재시간값

토큰생성 메서드를 구현한다
	: https://samtao.tistory.com/65
	: https://escapefromcoding.tistory.com/255
   	 : 로그인이 성공했을 떄 successfulHandelr 에 의해 실행된다
	: 토큰의 타입은 String 이기 떄문에 이 메서드의 반홚형은 String
    	: 토큰객체생성 >> Jwts.builder() 
	: claim 저장 >>
		: claim >> 토큰 payload 들어갈 key-value 쌍
		1. custom claim .사용자지정클레임 :  claim( "키명", 값 ) ;
		2. Standard Claims . 기본적으로 등록되있는 클레임. :  Jwt 가 제공하는 setter 메서드 활용
			setIssuer("값")
			setSubject("값") 
			setAudience("값")
			setExpiration("값") >> 주로 .expiration(new Date(System.currentTimeMillis() + ms단위의커스텀시간 )) 
		    	:토큰의 소멸시간을 저장

			setNotBefore("값")
			setIssuedAt("값") >> 주로  .setIssuedAt(new Date()) 
			setId("값")
 
    	: 어떤 키로 암호화 할 지 정해준다. 그러니까 어떤 시크릿키를 사용하여 header 와 payload 를 base64 로 인코딩한 것을 또 암호화하여 시그니쳐 부분 문자열을 생성할 건지 지정한다.>> .signWith( 시크릿키객체 ) :
 
   	: 토큰설정이 끝나면 하는 마지막 과정으로, 토큰을 압축한다. >> .compact(); : 


@Component
public class JWTUtil {
   // 객체키를 저장
    private SecretKey secretKey;

   
    public JWTUtil(@Value("${spring.jwt.secret}")String secret) {   // 시크릿 키 불러오기
        // application.prperties 의 시크릿키값을 기반으로 객체타입의 키 생성
        this.secretKey = new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), Jwts.SIG.HS256.key().build().getAlgorithm());
    }



    //username 뽑아냄 . 검증.
    public String getUsername(String token){ 
        return Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload().get("username",String.class);

    }


// role 뽑아냄. 검증
    public String getRole(String token){
        return Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload().get("role",String.class);
    }

    // 토큰완료여부확인. 소멸되면 true 아니면 false
    public boolean isExpired(String token){
        return Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload().getExpiration().before(new Date());    }

    //토큰생성 
    public String createJwt(String username , String role, Long expiredMs){
        return Jwts.builder()
                .claim("username", username)
                .claim("role", role)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + expiredMs))
                .signWith(secretKey)
                .compact();    }


}




 참고 > 0.11.5 구현

@Component
public class JWTUtil {

    private Key key;

    public JWTUtil(@Value("${spring.jwt.secret}")String secret) {


				byte[] byteSecretKey = Decoders.BASE64.decode(secret);
        key = Keys.hmacShaKeyFor(byteSecretKey);
    }

    public String getUsername(String token) {

        return Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token).getBody().get("username", String.class);
    }

    public String getRole(String token) {

        return Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token).getBody().get("role", String.class);
    }

    public Boolean isExpired(String token) {

        return Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token).getBody().getExpiration().before(new Date());
    }

    public String createJwt(String username, String role, Long expiredMs) {

				Claims claims = Jwts.claims();
        claims.put("username", username);
        claims.put("role", role);

        return Jwts.builder()
                .setClaims(claims)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + expiredMs))
                .signWith(key, SignatureAlgorithm.HS256)
                .compact();
    }
} 


--------------------------------------------------------------------------------------------------------------

 로그인이 성공 했을 경우 JWT를 발급하기 위한 구현

구현한 JWTUtil 을 loginfilter.java 에 @Autowired 되게 해서 loginfilter.java 의 successfulAuthentication 메소드 에서 사용할 수 있ㄱ ㅔ 한다.


UsernamePasswordAuthenticationFilter 의 successfulAuthentication 는 authenticationManager 의 antuenticate( ) 과정이 성공적으로 끝나면 이벤트 헨들러에 의해 자동 호출된다. 그리고 authenticate 하는 과정에서 Userdetails 겍체와 role 값 등을 담고 있는 authentication 객체를 context 에 저장해놨으므로 successfulAuthentication 에서 arg 로 authentication 객체를 받아 userDetails 등의 정보를 빼내 쓸 수 있따.



CustomUserDetails customUserDetails = (CustomUserDetails) authentication.getPrincipal( );
	: authentication의 principal 필드는 userDetails 객체를 담고 있고 , Object 타입이기 때문에 강제형변환 시켜준다.



String username = customUserDetails.getUsername();
	: username 을 얻는다


 Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
Iterator<? extends GrantedAuthority> iterator = authorities.iterator();
GrantedAuthority auth = iterator.next(); >>
	: role 을 얻는다. 이렇게 코드가 복잡한건 successfulAuthentication 에서 복잡한 작업을 해서 그런게 아니라 role 들의 값을 담는 authorities 가 collection 타입이기 때무에 그런거다. 
	: 만약에 role 이 하나가 아니었다면 List<GrantedAuthority> 이런 식으로 받아야됬겠지.

String role = auth.getAuthority() >>
	: 앞서 구한 GrantedAuthority 에서 role 명을 뽑아낸다

String token = jwtUtil.createJwt(username, role, 60*60*10L) >>
	: 앞서 구현한 jwtUtil 의 메서드를 활용하여 현재 메서드에서 뽑은 정보를 기반으로 token 을 생성한다
     


response.addHeader("Authorization", "Bearer " + token) >>
response header 에 토큰을 추가한다.
HTTP 인증 방식은 RFC 7235 정의에 따라 아래와 같은 형식으로 response header 에  토큰을 추가해야된다 
	:    response.addHeader("Authorization", "Bearer " + token);

	: 형식 >>Authorization: 타입 인증토큰
		: 그러니까 key 값은 "Authorization" , value값은 "타입명" + 문자열토큰값.	
		: ex )  Authorization: Bearer 인증토큰명 >> response.addHeader("Authorization","Bearer " + 인증토큰명); 

	: 인증토큰 type 의 종류
		Baic : 사용자 아이디와 암호를 Base64로 인코딩한 값을 토큰으로 사용
		Bearer : JWT 혹은 Oauth에 대한 토큰을 사용
		Mutual : 암호를 이용한 클라이언트 - 서버 상호 인증
		AWS4-HMAC-SHA256 : AWS 전저 서명 기반 인증
		. . .



public class LoginFilter extends UsernamePasswordAuthenticationFilter {

    private final AuthenticationManager authenticationManager;
		
	private final JWTUtil jwtUtil; //JWTUtil 객체 저장할 필드

// 직접 주입 >> SpringConfig 부분에서 주입된다
    public LoginFilter(AuthenticationManager authenticationManager, JWTUtil jwtUtil) {
        this.authenticationManager = authenticationManager;
	this.jwtUtil = jwtUtil;
    }


	. . .


	//로그인 성공시 실행하는 메소드 (여기서 JWT를 발급하면 됨)
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authentication) {

        CustomUserDetails customUserDetails = (CustomUserDetails) authentication.getPrincipal( );

        String username = customUserDetails.getUsername();

        Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
        Iterator<? extends GrantedAuthority> iterator = authorities.iterator();
        GrantedAuthority auth = iterator.next();

        String role = auth.getAuthority();

        String token = jwtUtil.createJwt(username, role, 60*60*10L);

        response.addHeader("Authorization", "Bearer " + token);
    }
    }


//로그인 실패시 실행하는 메소드
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) {
	// 일단 간단히 response 부분에 상태코드만 찍어서 보내줌
	response.setStatus(401);


    }
}





토큰을 받았으면 이후 requet 할 때 header 에 토큰키명("authorization")을  reqesut header 에 넣어 request 해야 해당 권한을 누릴 쑤 있다

--------------------------------------------------------------------------------------------------------------

jwt 검증 필터 . 토큰 검증 필터.
 : stateless 지만 한번의 request 대해 일시적으로 session 을 만드는 방식의 필터.
	: 세션을 이용하지만 stateless 로 관리되어 한번의 request 만 기억해서, 다시 동일한 요청을 보내면 또 토큰 검증을 진행하여 또 다른 세션을 생성한다.


우리가 만든 필터는 역시나 SecurityConfg 에 등록해줘야 효력이 발생한다.

jwtFilter 구현 후 등록.
	:: jwt 패키지 내에 생성

@Slf4j
// OncePerRequestFilter >> 요청에 대해서 한번만 동작하는 필터
public class JwtFilter extends OncePerRequestFilter {


    private final JWTUtil jwtUtil;


    public JwtFilter( JWTUtil jwtUtil){
        this.jwtUtil = jwtUtil;
    }

    // 필터 내부 작업에 대한 구현
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        // ( "Bearer" 가 접두사로 붙은) authorization 값을 request 에서 뽑아내서 검증 진행
        String authorization= request.getHeader("Authorization");

        //Authorization 헤더 검증
        if (authorization == null || !authorization.startsWith("Bearer ")) { // 토큰이 아예 없거나 jwt 타입의 토큰이 아니면
            log.info("JwtFilter: token null");
            filterChain.doFilter(request, response); // 현재 필터에서 받은 request 와 response 를 다음 필터에게 넘겨주며 현재 필터는 종료함
            return; // 메서드 종료
        }

        log.info("JwtFilter : token get");
        // 순수 토큰 획득
            //  authorization.split(" ") >> 띄어쓰기 단위로 요소로 포함하는 String 타입 배열 반환
            // authorization.split(" ") [1] >> 생성된 문자열 배열에서 1 번째 객체 반환. 즉, bearer 접두사 다음 찐 토큰 부분
        String token = authorization.split( " ")[1];

        // 토큰 소멸 시간 검증
        if (jwtUtil.isExpired(token)) {
            log.info("JwtFilter :token expired");
            filterChain.doFilter(request, response);
            return;
        }

        // 토큰이 유효한게 검증되면 해당 토큰을 기반으로 일시적인 세션을 하나 만들고, security context holder 라는 세션에다가 우리의 user를 일시적으로 저장시켜주면 다른 클래스에서 해당 정보를 뽑아서 권한을 확인 할 수 있게 된다

        //토큰에서 username과 role 획득
        String username = jwtUtil.getUsername(token);
        String role = jwtUtil.getRole(token);

        //userEntity를 생성하여 값 set
            // 굳이 dto 가 아니라 userEntity 로 만드는건 앞서 CustomUserDetails 에서 entity 를 기반으로 CustomUserDetails 객체를 생성하게 했었기 때문. 쩄뜬 CustomUserDetails 객체를 만들기 위한 과정
            // 주의 >> 비밀번호 값은 토큰에 담기지 않았었음. 그렇다고 여기서 비밀번호를 db에서 조회 매번 요청이 올때 마다 db 조회하는 꼴이 되버리기 떄문에, 여기선 찐 pw 값을 넣는다기 보다는 일시적인 password 값을 임의로 설정해서 넣어준다. 이미 인증이 되었는데 contex t hodler 에 정확한 비밀번호 입력할 필요가 굳이 없기 떄문ㄴ.
        UserEntity userEntity = new UserEntity();
        userEntity.setUsername(username);
        userEntity.setPassword("temppassword"); // 임시적인 비밀번호로 초기화
        userEntity.setRole(role);

        //UserDetails에 회원 정보 객체 담기
        CustomUserDetails customUserDetails = new CustomUserDetails(userEntity);

        // UserDetails 객체를 기반으로 UsernamePasswordAuthenticationToken 토큰 생성
        Authentication authToken = new UsernamePasswordAuthenticationToken(customUserDetails, null, customUserDetails.getAuthorities());

        //세션(SecurityContextHolder)에 사용자 등록 . 해당 user 에 대한 세션 생성
        SecurityContextHolder.getContext().setAuthentication(authToken);

        filterChain.doFilter(request, response); // 다음 필터에 reqeust , response 넘겨주면서 현재 필터를 종료함

    }




}



필터 등록

@EnableWebSecurity
@Configuration
public class SecurityConfig {


    private final JWTUtil jwtUtil;

   . ..

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http)throws Exception {

	 ..  . 

        //JWTFilter 등록 >> LoginFilter 앞에다가 
        http.addFilterBefore(new JwtFilter(jwtUtil), LoginFilter.class);

	. . .
        return http.build(); // 빌더 타입으로 리턴
    }
}







