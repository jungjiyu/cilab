-- 스프링 시큐리티 JWT -- 

https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC


--------------------------------------------------------------------------------------------------------------

@Bean 에 파라미터가 있을 경우 자동으로 DI 된다. @Bean  에 @Autowired 있다고 보면 된다.

https://kimcoder.tistory.com/459

https://www.logicbig.com/tutorials/spring-framework/spring-core/javaconfig-methods-inter-dependency.html


https://www.inflearn.com/questions/796060/bean-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EC%9E%88%EC%9D%84-%EA%B2%BD%EC%9A%B0-%EB%B9%88-%EC%83%9D%EC%84%B1-%EB%93%B1%EB%A1%9D-%EC%88%9C%EC%84%9C


--------------------------------------------------------------------------------------------------------------

JWT 인증 방식 시큐리티 동작 원리
	: 회원가입 >>  ( 클라이언트에게 폼데이터로 요청받는게 아니라 JSON 으로 요청받는건 다르지만) 내부적인 로직은 세션 방식과 JWT 방식의 차이가 없다.

	: 로그인 (인증) >>  로그인 요청을 받은 후 세션 방식은 서버 세션이 유저 정보를 저장하지만 JWT 방식은 토큰을 생성하여 응답한다.
		: 세션 방식과는 다르게 직접 필터 로직을 작성해야된다
		: UserDetails 구해서 검증하는 것 까지는 세션방식과 같지만, 로그인이 성공했을 떄 그 정보를 저장하는 방식이 다르다.  세션에다가 유저 정보를 저장하지 않고 JWT 토큰을 만들어 response .

	: 경로 접근 (인가) >> JWT Filter를 통해 요청의 헤더에서 JWT를 찾아 검증을하고 일시적 요청에 대한 Session을 생성한다. (생성된 세션은 요청이 끝나면 소멸됨)
		: JWT Filter 우리가 강제로. 필수적으로 커스텀해서 만들어야됨
		: JWT Filter 에서 해당 토큰이 알맞게 존재하고 일치하면 일시적인 세션을 만들고, 특정한 경로로 요청할 경우 그 세션에 정보가 저장되있기 떄문에 그 특정 경로에 접근 가능하게 된다.
		: stateless 로 관리되기 떄문에 단 하나의 세션에 대해서만 일시적으로 만들고 그 요청이 끝나버리면 세션이 다시 사라진다. 그러니까 새로운 요청을 받으면 동일한 아이디라도 그 요청에 대한 세션을 또 따로 만든다.



--------------------------------------------------------------------------------------------------------------

의존성 추가

- 필수 의존성
    - Lombok
    - Spring Web
    - Spring Security
    - Spring Data JPA
    - MySQL Driver

일단 데이터베이스 의존성 임시로 주석 처리>> 스프링 부트에서 데이터베이스 의존성을 추가한 뒤 연결을 진행하지 않을 경우 런타임 에러 발생
//	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
//	runtimeOnly 'com.mysql:mysql-connector-j'


### JWT 필수 의존성
	: 이건 직접 수동으로 추가해야된다.
	: 대부분은 JWT 0.11.5 버전을 통해 구현하지만 최신 버전은 0.12.3
		: 버전별로 구현 방법이 매우 다르다.

0.12.3 추가 방법

dependencies {
	. . .
    implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
    implementation 'io.jsonwebtoken:jjwt-impl:0.12.3'
    implementation 'io.jsonwebtoken:jjwt-jackson:0.12.3'
	. . .
}


0.11.5 추가 방법

dependencies {
	. . .

    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    implementation 'io.jsonwebtoken:jjwt-impl:0.11.5'
    implementation 'io.jsonwebtoken:jjwt-jackson:0.11.5'
	. . .

}




--------------------------------------------------------------------------------------------------------------

HTTP 프로토콜 >>  Connectionless , Stateless 하기 떄문에 로그인 후 다시 웹페이지에 접근하면 로그인상태가 유지되지 않는다. 이러한 HTTP 프로토콜의 인증 문제( 새 요청마다 기존 연결 끊김 )를 해결하기 위해 세션과 쿠키를 사용한다.
	: Connectionless >> request 이후 response 받으면 연결이 끊어진다
	: Stateless >> 통신이 종료되면(connection 끊어지면) 어떠한 상태도 남지 않는다




Session Id : 세션 식별정보
	: Session Cookie 에 저장되어 있는 값으로, Session 의 id 값을 말한다.
	: 이 값으로 서버에서 로그인 된 사용자의 세션을 식별가능해진다.
	: 사용자가 동일해도 여러개의 세션을 가질 수 있다


Session Cookie : 클라이언트의 쿠키로 저장된 세션 데이터 전체(JSESSIONID, PHPSESSIONID 등)를 의미
	: 브라우저가 종료되면 자동으로 삭제되는 휘발성 쿠키
	: 서버가 클라이언트에 세션ID를 클라이언트에게 부여하는 방법 중 하나로, 세션 식별정보를 쿠키에 담아 저장하는 것.
	: ( JSESSIONID 등의 이름의) 쿠키로 세션ID를 클라이언트에 저장해놓으면 클라이언트는 앞으로 모든 요청 헤더에 이 쿠키값을 포함시켜 보내고, 서버가 이를 식별할 수 있고, 이 값을 통해 세션을 유지할 수 있도록 한다(==JSESSIONID값을 기준으로 서버에서는 세션 메모리 영역에 상태를 유지할 값들을 저장할 수 있게 된다. (HttpSession 등) ).

	: 쿠키의 만료시간이 되면 클라이언트 측 쿠키는 소멸되기 때문에( 더이상 해당 세션ID를 가지지 않아서) 동일한 클라이언트가 보낸 요청이라고 해도 서버는 새로운 클라이언트로 인식하게 된다. 하지만 이전에 서버측에 생성된 세션 정보는 유지될 수 있고, 아직 "Invalidate"가 되지 않는다.
		: 세션 타임아웃
			; HTTP는 connectionless하고 stateless이기 때문에 클라이언트측의 세션 쿠키 소멸을 서버가 직접적으로 알 수 없다. 그렇기 때문에  클라이언트측의 세션 쿠키가 소멸되었다고해서 서버 내의 세션의 삭제도 즉시 이루어지는게 아니라 일정 시간 동안 유지된다.. 서버는 일정 시간이 지나면서 세션 데이터를 만료시키고 삭제하게 되어있는데, 이 시간을 '세션 타임아웃'이라고 부름.  
			: 세션 타임아웃이 되면 서버는 해당 세션 데이터를 삭제하고, 인지할 수 없는 세션 Id 를 포함하는 요청에 대해서는 새로운 세션을 생성함. 
		 :https://www.inflearn.com/questions/853519/%EC%84%B8%EC%85%98-%EC%82%AD%EC%A0%9C-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8



동작 방식
	1. 유효한 JsessionId없이 reqeust 할 시(브라우저에 최초 접근 시) 톰캣은 session ID값 발급하고이를 Response 헤더에  포함하여 response
	2. 이후 해당  session ID값을 헤더에 포함해 reqeust 할 시(브라우저 재요청시) 서버는 새로운  session ID값을 발급하진 않고 , 클라이언트로부터 전달받은  session ID값을 기준으로 서버의 세션 메모리 영역에 상태를 유지할 값들을 저장/접근하여 사용한다.
 

세션 단점
	1. 세션 쿠키 자체에는 세션 id 값만 있지, 유의미한 정보를 가지지 않기 떄문에 Http 요청 중 노출되어도 큰 문제는 없으나, 그 쿠키 자체를 훔쳐 ( 세션 하이재킹 ) 서버에 해당 쿠키로 접근하면 중요한 정보를 뺴낼 수 있다는 문제점이 있다.

	2. 서버에 세션을 저장하기 떄문에 사용자수가 많아지면 서버의 부담이 커진다.



세션 유효 범위
	 : https://dololak.tistory.com/543
	: 쿠키는 기본적으론 쿠키가 생성된 서버로만 전송됨. 그러니까 google 에서 생성된 쿠키는 naver 로 request 할 떄 전송되지 않음. 
	: 대규모 웹 서비스는 하나의 웹서버가 아닌 여러 웹서버가 하나의 시스템을 이루면서 운영되는 경우가 있는데 다른 서버에도 해당 쿠키가 전송되게 하려면 다른 방법이 필요 << 추후 기술
	: 동일한 Full 도메인 ( 서브도메인이 다를 경우 쿠키가 유지되지 않기 때문)
  

 

 

세션과 토큰 인증 방식 Stateless, stateful
	: Stateless >> 서버에서 Http와 같은 cilent 의 이전 상태를 기록하지 않는 접속
		: caching, load balancing, scale out 등의 장점이 있지만 매 요청마다 클라이언트의 상태정보를 전달받아야되기 떄문에 네트워크 자원을 소모하며, 서버는 정보 처리를 위한 작업이 필요
		: REST api 에서 각각의 요청은 독립적인 stateless 방식

	: Stateful >>  세션 기반 인증 방식. 서버에서 클라이언트의 이전 상태를 기록.
	: https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC
	: https://russwest.tistory.com/40\


토큰 인증 방식
	: 서버의 토큰을 이용하여 인증을 수행하는 방법
	: 세션 기반 인증방식인 stateful 과는 다르게 서버에 클라이언트의 상태 정보를 저장하지 않아서 서버의 부담을 줄일 수 있다
	1. 사용자가 토큰없이(최초로그인) request 
	2. 서버가 사용자 검증 통해 유효성 확인 후 통과하면 토큰을 response 와 함꼐 반환
	3. 클라이언트는 토큰을 저장하고, 서버 요청 시  request 할 떄마다 토큰을 request header 에 담아서 보냄
	4. 서버는 토큰 검증 후 요청에 respnose.

토큰 방식 장점
	1. 서버 부담 감소 : 일일이 사용자의 정보를 저장할 필요 없음
	2. csrf 방지 : 

--------------------------------------------------------------------------------------------------------------
SecurityConfig 클래스  >> 스프링 시큐리티의 인가 및 설정을 담당하는 클래스
	: 버전별로 구현 방법이 다르다. 실습은 6.2.1 기준 진행된다
	:  
		1. bCryptPasswordEncoder 메서드 >> pw 암호화 위해 빈 등록
		2. filterChain 메서드 >> 세션을 stateless 하게 설정 / stateless 하므로 csrf 설정을 해제 / jwt 로 로그인 할 것이니 formlogin 과 httpbasic 기능 모두 해제 / 경로별 인가 작업


@EnableWebSecurity
@Configuration
public class SecurityConfig {

    // 암호화 위해 BCryptPaasswordEncoder 등록
    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http)throws Exception {
        // JWT를 통한 인증/인가를 위해서 세션을 STATELESS 상태로 설정
        http.sessionManagement(session->session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS));

        //csrf 해제
        //세션 방식의 Spring security 의 경우 세션 방식이 고정되있어 csrf 공격에 필수적으로 대비해줘야되지만 jwt 는 stateless 하게 관리하기 떄문에 별다른 대비가 필요없다
        http.csrf(auth->auth.disable());


// jwt 로 로그인 할거라 FormLogin 방식, HttpBasic 모두 해제
        //From 로그인 방식 disable
        http.formLogin((auth) -> auth.disable());

        //http basic 인증방식 disable
        http.httpBasic((auth) -> auth.disable());


        // 경로별 인가 작업
        http.authorizeHttpRequests(auth->auth
                .requestMatchers("/login","/","/join").permitAll()
                .requestMatchers("/admin").hasRole("ADMIN")
                .anyRequest().authenticated());



        return http.build(); // 빌더 타입으로 리턴
    }
}



--------------------------------------------------------------------------------------------------------------

POSTMAN >> API 클라이언트. API 기반 요청 보낼 수 있는 소프트웨어
	: post 요청이나 jwt 토큰 같은거 포함하는 요청은 일반 브라우저로 할 수 없어 깔아야됨.

--------------------------------------------------------------------------------------------------------------

DB 연결 및 Entity 와 Repository 선언

데이터베이스 의존성 주석 해제 > 이제 연결 설정할 거니까

 application.properteis 설정 > 

#db 연결
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://아이피:3306/데이터베이스?useSSL=false&useUnicode=true&serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true
spring.datasource.username=아이디
spring.datasource.password=비밀번호

#ddl > 이미 db에 해당 테이블이 존재한다묜 none 으로, 없다면 update 나 create .
spring.jpa.hibernate.ddl-auto=none
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl


회원 테이블 Entity 작성 : UserEntity >
@Entity
@Setter
@Getter
public class UserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    private String username;
    private String password;

    private String role;
}


회원 테이블 Repository 작성 : UserRepository > 논리적pk 존재여부 확인 위해 별도의 메서드 선언

public interface UserRepository extends JpaRepository<UserEntity, Integer> {

    public abstract   Boolean existsByUsername(String username);
    public abstract UserEntity findByUsername(String username);


}



--------------------------------------------------------------------------------------------------------------

회원가입 로직 >>

RestController 와 Service 단 선언


@RestController
public class JoinController {
    

    @Autowired
    private JoinService joinService;

    @PostMapping("/join")
    public ResponseEntity<JoinDTO> joinP(JoinDTO dto){
        JoinDTO saved = joinService.JoinP(dto);
        return ResponseEntity.status(HttpStatus.OK).body(saved);
    }
}



서비스 단에서 password 암호화 한 후에 저장해야함 까먹지 x.

@Service
public class JoinService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private BCryptPasswordEncoder bCryptPasswordEncoder;

    public JoinDTO JoinP(JoinDTO dto){
        boolean exist = userRepository.existsByUsername(dto.getUsername());

        if(exist) return null;

        UserEntity entity = new UserEntity();
        entity.setPassword(bCryptPasswordEncoder.encode(dto.getPassword())); // 암호화를 한 후 넣어야됨
        entity.setUsername(dto.getUsername());
        entity.setRole("ROLE_ADMIN");
        userRepository.save(entity);
        return JoinDTO.toDTO(entity);

    }
}


--------------------------------------------------------------------------------------------------------------

로그인 필터 구현
	
세션 방식으로 Spring Security 를 구현 할 떄는 UsernamePasswordAutneticationFIlter 와 AthenthicationManager 를 별도로 구현하지 않아도 됬음. 근데 JWT 방식으로 할 떈 "formLogin 방식을 disable 시켰기 떄문에" 반드시 직접 구현 해줘야됨

UsernamePasswordAutneticationFIlter >> 사용자로부터 입력받은 데이터에서 username 과 password 정보를 꺼내서(걸러서) AthenthicationManager에게 넘겨줌

AthenthicationManager >> UsernamePasswordAutneticationFIlter 에게 받은 username 과 password 정보로 UserDetailsService 가 UserDetails를 사용해서 검증을 진행 및 결과 반환 

SuccessfulAthentication >>AthenthicationManager 에서 검증이 성공되면 실행된다. JWT 를 생성해서 사용자에게 응답해준다.


UnSuccessfulAthentication >> AthenthicationManager 에서 검증이 실패하면 실행된다.  JWT 를 따로 생성하진 않고 에러 코드만 보낸다.





스프링 시큐리티 동작 원리
	: 기본적인 스프링 부트의 동작 원리>> Servlet Container 에는 여러개의 필터가 있는데 사용자로부터 request 가 들어오면 ServletContainer 내부의 여러 필터를 거쳐서 SpringBoot , 즉 컨트롤러에 전달된다.
	
	: 스프링 시큐리티 동작원리 >> 사용자로부터 request 가 왔을 떄 스프링시큐리티는 Servlet Container 내부의 필터부애 도착한 request 를 가로채서 검증(인증/인가) 하고, 그  결과에 따라 컨트롤러에 전달해주고 안해준다.

		1. 스프링 시큐리티를 의존성으로 추가하면,  서블릿 필터 체인(Servlet Container 에 존재하는 필터 체인) 중간에 DelegatingFilter가 등록된다.
			: 이떄 DelegatingFilter 는 서블릿 필터 체인에 속한 필터인 것이다.
			: Delegate : 대표자. 위임자. >> 그러니까 DelegatingFilter는 역할을 ( 시큐리티 필터로 ) 위임하는 필터란 뜻

		2. DelegatingFilter 가 자신이 받은 요청을 시큐리티 필터 체인( Spring Security 가 관리하는 별도의 필터)의 필터에 전달한다.

		3. 시큐리티 필터체인 이 검증 결과에 따라 리다이렉션 거부 등의 동작을 수행한다


핵심 시큐리티 필터
	: UsernamePasswordAuthenticationFilter
		: request 로 보내진 username과 password로 회원 검증을 진행을 시행하는 부분,
		: formLogin 방식을 사용할 떄 해당 필터는 기본적으로 활성화되어 별다른 구현이 필요 없지만, formLogin 방식을 해제한 경우 직접 . 필수적으로 . 구현해야된다. 
			: https://docs.spring.io/spring-security/reference/servlet/architecture.html 에서 확인 가능( formLogin 방식 쓸 떄 UsernamePasswordAuthenticationFilter 가 add 되는 것.)



******커스텀 필터 : 직접 내용을 구현한 필터는 SecurityConfig에 등록해야 사용 가능하다





커스텀 UsernamePasswordAuthenticationFilter 구현
	: jwt 라는 패키지를 별도로 만들고 거기에 저장
	: 다 만들면 SecurityConfig.java 에 필터로 등록



public class LoginFilter extends UsernamePasswordAuthenticationFilter {
    //  attemptAuthentication 에서 authenticationManager 에게 토큰 전달위해 DI
    @Autowired
    private AuthenticationManager authenticationManager;


    //  필수로 오버라이드 필요
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {

	// 추출
        String username = obtainUsername(request);
        String password = obtainPassword(request);

        // DTO역할을 하는UsernamePasswordAuthenticationToken이라는 바구니에 넣음
       	 //UsernamePasswordAuthenticationToken(username값,password값,role값);
        UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(username,password,null); // 일단 당장은 role 이 없으니 null 값넣었다

        // 생성한 토큰을 AthenthicationManager 에게 넘겨줌 --> authenticationManager 가 알아서 검증해줌
        return authenticationManager.authenticate(authToken);
    }



    // authenticationManager 가 성공적으로 검증을 마쳤을 때 실행되는 메서드 . 여기서 JWT 를 발급한다!!!
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {

       구 현

    }


    //  authenticationManager 가 검증을 실패했을때 실행되는 메서드
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
       
		구 현

    }



}







attemptAuthentication 는 필수로 오버라이딩한다. 이 메서드가 요청을 가로채서 username 과 password 추출하고, 이를 기반으로 토큰을 만들고, AthenthicationManager에게 해당 토큰을 전달하게 된다.

obtainUsername , obtainPassword 메서드를 통해 request 객체에서 각각 username 과 password 를 추출한다. 

AthenthicationManager에게 그냥 띡 username 과 password 를 전달해주면 안되고,  해당 정보를 DTO역할을 하는UsernamePasswordAuthenticationToken이라는 바구니에 담아서 전달해줘야 하기 떄문ㅇㅔ UsernamePasswordAuthenticationToken 객체 그러니까 토큰을 생성한다. 생성자의 arg 로는 username값, password값, role값이 들어간다.


AthenthicationManager에게 생성한 토큰을 전달해주기 위해서 AthenthicationManager 의 authenticate 메서드가 필요함으로 AuthenticationManager 를 @Autowired 받게 하고 그 객체를 대상으로 authenticate 메서드를 사용하며 앞서 생성한 토큰을 arg 로 한다
	: AthenthicationManager 은 별도로 @Bean 등록이 되지 않은 상태이므로 잊지말고 SpringConfig 에서 @Bean 등록해준다.

@EnableWebSecurity
@Configuration
public class SecurityConfig {

	. . .

    //AuthenticationManager Bean 등록
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception {

        return configuration.getAuthenticationManager();
    }
. .. 

}



AthenthicationManager가 인증을 성공적으로 마쳤을 경우 수행될 successfulAuthentication 와 unsuccessfulAuthentication 또한 오버라이드한다
	: 참고로 이 둘은 UsernamePasswordAuthenticationFilter의 직속 메서드는 아니고 그의 인터페이스인 AbstractAuthenticationProcessingFilter의 추상 메서드이다.

	: successfulAuthentication 에서 jwt 를 발급하게 된다.




만든 필터 등록 >> SecurityConfig 에서 addFilterXX ( 내가만든필터객체 , 기존필터명.class )  를 활용한다.
            addFilterAt(  내가만든필터객체 , 기존필터명.class) >> 딱 그자리에 필터를 등록. 즉, 특정원본필터를 대체
		: 그러니까 부모를 자식으로 대체하려면 이걸활용해야된다.

            addFilterBefore( 내가만든필터객체 , 기존필터명.class ) >> 특정필터 앞에 해당 필터 추가 
            addFilterAfter(  내가만든필터객체 , 기존필터명.class) >> 특정필터 뒤에 해당 필터 추가


@EnableWebSecurity
@Configuration
public class SecurityConfig {


    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http)throws Exception {

	. . .
        
      
        http.addFilterAt(new LoginFilter(), UsernamePasswordAuthenticationFilter.class);


	. . . 

        return http.build(); // 빌더 타입으로 리턴
    }
}








--------------------------------------------------------------------------------------------------------------

AuthenticationManager 이후 부분( userdetails 	~  db ) 은  세션 방식과 동일

CustomUserDetailsService 는 인증하는 부분이지, 새 user 를 등록하는 부분이 아니다.
	: 
	: 새 user 를 등록하는건 별도로 JoinController 같은거 만들어서 한다.



@EqualsAndHashCode
@ToString
@AllArgsConstructor
@NoArgsConstructor
public class CustomUserDetails implements UserDetails {

    private UserEntity userEntity;


    // roll 값들을 반환한다.
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {

        Collection<GrantedAuthority> collections = new ArrayList<>();

        // 해당 entity 의 roll 값을 뽑아서 collection 에 add 한다
        collections.add(new GrantedAuthority() {
            @Override
            public String getAuthority() {
                return userEntity.getRole();
            }
        });

        return List.of();
    }

    @Override
    public String getPassword() {
        return userEntity.getPassword();
    }

    @Override
    public String getUsername() {
        return userEntity.getUsername();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
}




@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    // 로그인 검증 용 . db의 정보와 일치하는가
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        UserEntity entity = userRepository.findByUsername(username);

        if(entity!=null)return new CustomUserDetails(entity);

        return null;
    }
}

	
