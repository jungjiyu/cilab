-- 스프링 시큐리티 JWT -- 

https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC




--------------------------------------------------------------------------------------------------------------

JWT 인증 방식 시큐리티 동작 원리
	: 회원가입 >>  ( 클라이언트에게 폼데이터로 요청받는게 아니라 JSON 으로 요청받는건 다르지만) 내부적인 로직은 세션 방식과 JWT 방식의 차이가 없다.

	: 로그인 (인증) >>  로그인 요청을 받은 후 세션 방식은 서버 세션이 유저 정보를 저장하지만 JWT 방식은 토큰을 생성하여 응답한다.
		: 세션 방식과는 다르게 직접 필터 로직을 작성해야된다
		: UserDetails 구해서 검증하는 것 까지는 세션방식과 같지만, 로그인이 성공했을 떄 그 정보를 저장하는 방식이 다르다.  세션에다가 유저 정보를 저장하지 않고 JWT 토큰을 만들어 response .

	: 경로 접근 (인가) >> JWT Filter를 통해 요청의 헤더에서 JWT를 찾아 검증을하고 일시적 요청에 대한 Session을 생성한다. (생성된 세션은 요청이 끝나면 소멸됨)
		: JWT Filter 우리가 강제로. 필수적으로 커스텀해서 만들어야됨
		: JWT Filter 에서 해당 토큰이 알맞게 존재하고 일치하면 일시적인 세션을 만들고, 특정한 경로로 요청할 경우 그 세션에 정보가 저장되있기 떄문에 그 특정 경로에 접근 가능하게 된다.
		: stateless 로 관리되기 떄문에 단 하나의 세션에 대해서만 일시적으로 만들고 그 요청이 끝나버리면 세션이 다시 사라진다. 그러니까 새로운 요청을 받으면 동일한 아이디라도 그 요청에 대한 세션을 또 따로 만든다.



--------------------------------------------------------------------------------------------------------------

의존성 추가

- 필수 의존성
    - Lombok
    - Spring Web
    - Spring Security
    - Spring Data JPA
    - MySQL Driver

일단 데이터베이스 의존성 임시로 주석 처리>> 스프링 부트에서 데이터베이스 의존성을 추가한 뒤 연결을 진행하지 않을 경우 런타임 에러 발생
//	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
//	runtimeOnly 'com.mysql:mysql-connector-j'


### JWT 필수 의존성
	: 이건 직접 수동으로 추가해야된다.
	: 대부분은 JWT 0.11.5 버전을 통해 구현하지만 최신 버전은 0.12.3
		: 버전별로 구현 방법이 매우 다르다.

0.12.3 추가 방법

dependencies {
	. . .
    implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
    implementation 'io.jsonwebtoken:jjwt-impl:0.12.3'
    implementation 'io.jsonwebtoken:jjwt-jackson:0.12.3'
	. . .
}


0.11.5 추가 방법

dependencies {
	. . .

    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    implementation 'io.jsonwebtoken:jjwt-impl:0.11.5'
    implementation 'io.jsonwebtoken:jjwt-jackson:0.11.5'
	. . .

}




--------------------------------------------------------------------------------------------------------------

HTTP 프로토콜 >>  Connectionless , Stateless 하기 떄문에 로그인 후 다시 웹페이지에 접근하면 로그인상태가 유지되지 않는다. 이러한 HTTP 프로토콜의 인증 문제( 새 요청마다 기존 연결 끊김 )를 해결하기 위해 세션과 쿠키를 사용한다.
	: Connectionless >> request 이후 response 받으면 연결이 끊어진다
	: Stateless >> 통신이 종료되면(connection 끊어지면) 어떠한 상태도 남지 않는다




Session Id : 세션 식별정보
	: Session Cookie 에 저장되어 있는 값으로, Session 의 id 값을 말한다.
	: 이 값으로 서버에서 로그인 된 사용자의 세션을 식별가능해진다.
	: 사용자가 동일해도 여러개의 세션을 가질 수 있다


Session Cookie : 클라이언트의 쿠키로 저장된 세션 데이터 전체(JSESSIONID, PHPSESSIONID 등)를 의미
	: 브라우저가 종료되면 자동으로 삭제되는 휘발성 쿠키
	: 서버가 클라이언트에 세션ID를 클라이언트에게 부여하는 방법 중 하나로, 세션 식별정보를 쿠키에 담아 저장하는 것.
	: ( JSESSIONID 등의 이름의) 쿠키로 세션ID를 클라이언트에 저장해놓으면 클라이언트는 앞으로 모든 요청 헤더에 이 쿠키값을 포함시켜 보내고, 서버가 이를 식별할 수 있고, 이 값을 통해 세션을 유지할 수 있도록 한다(==JSESSIONID값을 기준으로 서버에서는 세션 메모리 영역에 상태를 유지할 값들을 저장할 수 있게 된다. (HttpSession 등) ).

	: 쿠키의 만료시간이 되면 클라이언트 측 쿠키는 소멸되기 때문에( 더이상 해당 세션ID를 가지지 않아서) 동일한 클라이언트가 보낸 요청이라고 해도 서버는 새로운 클라이언트로 인식하게 된다. 하지만 이전에 서버측에 생성된 세션 정보는 유지될 수 있고, 아직 "Invalidate"가 되지 않는다.
		: 세션 타임아웃
			; HTTP는 connectionless하고 stateless이기 때문에 클라이언트측의 세션 쿠키 소멸을 서버가 직접적으로 알 수 없다. 그렇기 때문에  클라이언트측의 세션 쿠키가 소멸되었다고해서 서버 내의 세션의 삭제도 즉시 이루어지는게 아니라 일정 시간 동안 유지된다.. 서버는 일정 시간이 지나면서 세션 데이터를 만료시키고 삭제하게 되어있는데, 이 시간을 '세션 타임아웃'이라고 부름.  
			: 세션 타임아웃이 되면 서버는 해당 세션 데이터를 삭제하고, 인지할 수 없는 세션 Id 를 포함하는 요청에 대해서는 새로운 세션을 생성함. 
		 :https://www.inflearn.com/questions/853519/%EC%84%B8%EC%85%98-%EC%82%AD%EC%A0%9C-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8



동작 방식
	1. 유효한 JsessionId없이 reqeust 할 시(브라우저에 최초 접근 시) 톰캣은 session ID값 발급하고이를 Response 헤더에  포함하여 response
	2. 이후 해당  session ID값을 헤더에 포함해 reqeust 할 시(브라우저 재요청시) 서버는 새로운  session ID값을 발급하진 않고 , 클라이언트로부터 전달받은  session ID값을 기준으로 서버의 세션 메모리 영역에 상태를 유지할 값들을 저장/접근하여 사용한다.
 

세션 단점
	1. 세션 쿠키 자체에는 세션 id 값만 있지, 유의미한 정보를 가지지 않기 떄문에 Http 요청 중 노출되어도 큰 문제는 없으나, 그 쿠키 자체를 훔쳐 ( 세션 하이재킹 ) 서버에 해당 쿠키로 접근하면 중요한 정보를 뺴낼 수 있다는 문제점이 있다.

	2. 서버에 세션을 저장하기 떄문에 사용자수가 많아지면 서버의 부담이 커진다.



세션 유효 범위
	 : https://dololak.tistory.com/543
	: 쿠키는 기본적으론 쿠키가 생성된 서버로만 전송됨. 그러니까 google 에서 생성된 쿠키는 naver 로 request 할 떄 전송되지 않음. 
	: 대규모 웹 서비스는 하나의 웹서버가 아닌 여러 웹서버가 하나의 시스템을 이루면서 운영되는 경우가 있는데 다른 서버에도 해당 쿠키가 전송되게 하려면 다른 방법이 필요 << 추후 기술
	: 동일한 Full 도메인 ( 서브도메인이 다를 경우 쿠키가 유지되지 않기 때문)
  

 

 

세션과 토큰 인증 방식 Stateless, stateful
	: Stateless >> 서버에서 Http와 같은 cilent 의 이전 상태를 기록하지 않는 접속
		: caching, load balancing, scale out 등의 장점이 있지만 매 요청마다 클라이언트의 상태정보를 전달받아야되기 떄문에 네트워크 자원을 소모하며, 서버는 정보 처리를 위한 작업이 필요
		: REST api 에서 각각의 요청은 독립적인 stateless 방식

	: Stateful >>  세션 기반 인증 방식. 서버에서 클라이언트의 이전 상태를 기록.
	: https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC
	: https://russwest.tistory.com/40\


토큰 인증 방식
	: 서버의 토큰을 이용하여 인증을 수행하는 방법
	: 세션 기반 인증방식인 stateful 과는 다르게 서버에 클라이언트의 상태 정보를 저장하지 않아서 서버의 부담을 줄일 수 있다
	1. 사용자가 토큰없이(최초로그인) request 
	2. 서버가 사용자 검증 통해 유효성 확인 후 통과하면 토큰을 response 와 함꼐 반환
	3. 클라이언트는 토큰을 저장하고, 서버 요청 시  request 할 떄마다 토큰을 request header 에 담아서 보냄
	4. 서버는 토큰 검증 후 요청에 respnose.

토큰 방식 장점
	1. 서버 부담 감소 : 일일이 사용자의 정보를 저장할 필요 없음
	2. csrf 방지 : 

--------------------------------------------------------------------------------------------------------------
SecurityConfig 클래스  >> 스프링 시큐리티의 인가 및 설정을 담당하는 클래스
	: 버전별로 구현 방법이 다르다. 실습은 6.2.1 기준 진행된다
	:  
		1. bCryptPasswordEncoder 메서드 >> pw 암호화 위해 빈 등록
		2. filterChain 메서드 >> 세션을 stateless 하게 설정 / stateless 하므로 csrf 설정을 해제 / jwt 로 로그인 할 것이니 formlogin 과 httpbasic 기능 모두 해제 / 경로별 인가 작업


@EnableWebSecurity
@Configuration
public class SecurityConfig {

    // 암호화 위해 BCryptPaasswordEncoder 등록
    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http)throws Exception {
        // JWT를 통한 인증/인가를 위해서 세션을 STATELESS 상태로 설정
        http.sessionManagement(session->session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS));

        //csrf 해제
        //세션 방식의 Spring security 의 경우 세션 방식이 고정되있어 csrf 공격에 필수적으로 대비해줘야되지만 jwt 는 stateless 하게 관리하기 떄문에 별다른 대비가 필요없다
        http.csrf(auth->auth.disable());


// jwt 로 로그인 할거라 FormLogin 방식, HttpBasic 모두 해제
        //From 로그인 방식 disable
        http.formLogin((auth) -> auth.disable());

        //http basic 인증방식 disable
        http.httpBasic((auth) -> auth.disable());


        // 경로별 인가 작업
        http.authorizeHttpRequests(auth->auth
                .requestMatchers("/login","/","/join").permitAll()
                .requestMatchers("/admin").hasRole("ADMIN")
                .anyRequest().authenticated());



        return http.build(); // 빌더 타입으로 리턴
    }
}



--------------------------------------------------------------------------------------------------------------

POSTMAN >> API 클라이언트. API 기반 요청 보낼 수 있는 소프트웨어
	: post 요청이나 jwt 토큰 같은거 포함하는 요청은 일반 브라우저로 할 수 없어 깔아야됨.

--------------------------------------------------------------------------------------------------------------

DB 연결 및 Entity 와 Repository 선언

데이터베이스 의존성 주석 해제 > 이제 연결 설정할 거니까

 application.properteis 설정 > 

#db 연결
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://아이피:3306/데이터베이스?useSSL=false&useUnicode=true&serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true
spring.datasource.username=아이디
spring.datasource.password=비밀번호

#ddl > 이미 db에 해당 테이블이 존재한다묜 none 으로, 없다면 update 나 create .
spring.jpa.hibernate.ddl-auto=none
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl


회원 테이블 Entity 작성 : UserEntity >
@Entity
@Setter
@Getter
public class UserEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    private String username;
    private String password;

    private String role;
}


### 회원 테이블 Repository 작성 : UserRepository > 
public interface UserRepository extends JpaRepository<UserEntity, Integer> {

}



--------------------------------------------------------------------------------------------------------------


